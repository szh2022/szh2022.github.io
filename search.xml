<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>My New Post</title>
    <url>/2023/12/27/My-New-Post/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/12/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>剑指Offer</title>
    <url>/2024/01/16/%E5%89%91%E6%8C%87Offer/</url>
    <content><![CDATA[<p>剑指Offer的刷题总结。最近LeetCode上下架了该合集，牛客上的合集也开始了收费。所幸各个题目还不收费，在此收集一下，并写一些题解以供复习。</p>
<span id="more"></span>

<h1 id="1-二维数组的查找"><a href="#1-二维数组的查找" class="headerlink" title="1.二维数组的查找"></a>1.二维数组的查找</h1><p><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&&tqId=11154&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">二维数组中的查找_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一："><a href="#法一：" class="headerlink" title="法一："></a>法一：</h3><p>从右上往左下找，由于每一行每一列都是递增的，</p>
<ul>
<li>当前位置小于target， target在下一行，h++。</li>
<li>当前位置大于target， target在这一行，w—。</li>
<li>相等，表示找到了返回true。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; array[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> row = array.<span class="built_in">size</span>(), col = array[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> h = <span class="number">0</span>, w = col - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(w &gt;= <span class="number">0</span> &amp;&amp; h &lt; row)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[h][w] &gt; target) w--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[h][w] &lt; target) h++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二："><a href="#法二：" class="headerlink" title="法二："></a>法二：</h3><p>不考虑每一列的顺序，只利用每一行的有序性，在每一行中都使用二分法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasFound</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; array,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>,end = array.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">            <span class="type">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[mid] &lt; target) start = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] &gt; target) end = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.<span class="built_in">size</span>() == <span class="number">0</span> || array[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;array.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">hasFound</span>(array[i],target)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2.替换空格"></a>2.替换空格</h1><p>​	<a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&&tqId=11155&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">替换空格_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>​	记得当时在Leetcode上做的时候参数是string，牛客是str，不过都一样。</p>
<h3 id="法一：-1"><a href="#法一：-1" class="headerlink" title="法一："></a>法一：</h3><p>若参数是string的话还得resize一下，str的话可以直接写，但这样其实本身并不优雅。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="type">char</span> *str,<span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(str[i] == <span class="string">&#x27; &#x27;</span>) cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span>	totalLength = length + <span class="number">2</span>* cnt;</span><br><span class="line">		str[totalLength] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = length,j = totalLength;i&gt;=<span class="number">0</span> &amp;&amp; i != j;i--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(str[i] != <span class="string">&#x27; &#x27;</span>) str[j--] = str[i];</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				str[j--] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				str[j--] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">				str[j--] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>如果参数是string的话就方法就更多了。</p>
<ul>
<li>正则</li>
<li>replace等</li>
</ul>
<h1 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3.从尾到头打印链表"></a>3.从尾到头打印链表</h1><p><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&&tqId=11156&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">从尾到头打印链表_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法1："><a href="#法1：" class="headerlink" title="法1："></a>法1：</h3><p>从前往后保存，然后reverse一下就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法2："><a href="#法2：" class="headerlink" title="法2："></a>法2：</h3><p>递归</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void recursion(ListNode<span class="operator">*</span> head,vector<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span><span class="operator">&amp;</span> ans)&#123;</span><br><span class="line">        if(head <span class="operator">!=</span> nullptr)&#123;</span><br><span class="line">            recursion(head<span class="operator">-</span><span class="operator">&gt;</span>next, ans);</span><br><span class="line">            ans.push_back(head<span class="operator">-</span><span class="operator">&gt;</span>val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> printListFromTailToHead(ListNode<span class="operator">*</span> head) &#123;</span><br><span class="line">        vector<span class="operator">&lt;</span><span class="type">int</span><span class="operator">&gt;</span> ans;</span><br><span class="line">        recursion(head,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法3："><a href="#法3：" class="headerlink" title="法3："></a>法3：</h3><p>还可以先弄到栈里，然后一个个出栈。但感觉跟法1的reverse区分度不大。代码略。</p>
<h1 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4.重建二叉树"></a>4.重建二叉树</h1><p><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&&tqId=11157&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">重建二叉树_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一：-2"><a href="#法一：-2" class="headerlink" title="法一："></a>法一：</h3><p>根据二叉树先序遍历和中序遍历的规则，找到根节点，递归建立二叉树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preOrder, vector&lt;<span class="type">int</span>&gt;&amp; vinOrder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(preOrder.<span class="built_in">size</span>() == <span class="number">0</span> || vinOrder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid = <span class="built_in">distance</span>(<span class="built_in">begin</span>(vinOrder),<span class="built_in">find</span>(vinOrder.<span class="built_in">begin</span>(),vinOrder.<span class="built_in">end</span>(),preOrder[<span class="number">0</span>]) );</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preOrder[<span class="number">0</span>]);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftPre</span><span class="params">(preOrder.begin() + <span class="number">1</span>,preOrder.begin() + mid + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightPre</span><span class="params">(preOrder.begin() + mid + <span class="number">1</span>,preOrder.end())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftVin</span><span class="params">(vinOrder.begin(),vinOrder.begin() + mid)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightVin</span><span class="params">(vinOrder.begin() + mid + <span class="number">1</span>,vinOrder.end())</span></span>;</span><br><span class="line">        root-&gt;left = <span class="built_in">reConstructBinaryTree</span>(leftPre, leftVin);</span><br><span class="line">        root-&gt;right = <span class="built_in">reConstructBinaryTree</span>(rightPre, rightVin);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二：-1"><a href="#法二：-1" class="headerlink" title="法二："></a>法二：</h3><p>空间换时间。每次都用distance去中序序列中找根节点太麻烦了，直接一开始用哈希表记录每个节点和它的索引。之后就不需要每次计算距离了，只要去查哈希表即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConCore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preOrder,unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; mp,<span class="type">int</span> root,<span class="type">int</span> start,<span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* tree = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preOrder[root]);</span><br><span class="line">        <span class="type">int</span> vinIndex = mp[preOrder[root]];</span><br><span class="line">        tree-&gt;left = <span class="built_in">reConCore</span>(preOrder, mp, root + <span class="number">1</span>, start, vinIndex - <span class="number">1</span>);</span><br><span class="line">        tree-&gt;right = <span class="built_in">reConCore</span>(preOrder, mp, (root + <span class="number">1</span>) + (vinIndex - start ), vinIndex + <span class="number">1</span> , end );</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preOrder, vector&lt;<span class="type">int</span>&gt;&amp; vinOrder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;vinOrder.<span class="built_in">size</span>();i++) mp.<span class="built_in">insert</span>(&#123;vinOrder[i],i&#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reConCore</span>(preOrder,mp,<span class="number">0</span>,<span class="number">0</span>,preOrder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="5-用两个栈来实现队列"><a href="#5-用两个栈来实现队列" class="headerlink" title="5.用两个栈来实现队列"></a>5.用两个栈来实现队列</h1><p><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&&tqId=11158&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">用两个栈实现队列_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>很简单，一个栈进，一个栈出。pop时如果出栈为空就把入栈的队列里的数据放放进出栈。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.<span class="built_in">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="keyword">if</span> (stack2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                temp = stack1.<span class="built_in">top</span>();</span><br><span class="line">                stack1.<span class="built_in">pop</span>();</span><br><span class="line">                stack2.<span class="built_in">push</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp = stack2.<span class="built_in">top</span>();</span><br><span class="line">        stack2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6.旋转数组的最小数字"></a>6.旋转数组的最小数字</h1><p><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&&tqId=11159&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">旋转数组的最小数字_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一：-3"><a href="#法一：-3" class="headerlink" title="法一："></a>法一：</h3><p>常规做法，直接遍历找第一个减小的数字。（也可以sort后，直接return nums[0]）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i<span class="number">-1</span>]) <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二：-2"><a href="#法二：-2" class="headerlink" title="法二："></a>法二：</h3><p>使用二分法。虽然数组不是完全有序，但</p>
<ul>
<li>每次<code>nums[mid] &lt; nums[right]</code>时，表示右边有序。</li>
<li>两者相等时，可能有两种情况或者是右边全是一个数，或者是最小值在右边（数值先小后大，故两者相等）。</li>
<li>每次<code>nums[mid] &gt; nums[right]</code>时，表示最小值在右边。</li>
<li>边界控制，由于最后left和right会控制相邻的两个数值中。故边界为<code>left + 1 &lt; right</code>。否则会陷入死循环。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[right]) right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == nums[right]) right--;</span><br><span class="line">            <span class="keyword">else</span> left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(nums[left],nums[right]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7.斐波那契数列"></a>7.斐波那契数列</h1><p><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&&tqId=11160&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">斐波那契数列_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>经典题目</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Fibonacci</span>(n<span class="number">-1</span>) + <span class="built_in">Fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8.跳台阶"></a>8.跳台阶</h1><p><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&&tqId=11161&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">跳台阶_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>经典题目。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number &lt;= <span class="number">2</span>) <span class="keyword">return</span> number;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">jumpFloor</span>(number - <span class="number">1</span>) + <span class="built_in">jumpFloor</span>(number - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="9-跳台阶扩展问题"><a href="#9-跳台阶扩展问题" class="headerlink" title="9.跳台阶扩展问题"></a>9.跳台阶扩展问题</h1><p><a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&&tqId=11162&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">跳台阶扩展问题_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一：-4"><a href="#法一：-4" class="headerlink" title="法一："></a>法一：</h3><p>经典dp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(number + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt; dp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">2</span>* dp[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二：-3"><a href="#法二：-3" class="headerlink" title="法二："></a>法二：</h3><p>发现规律，<code>2^(n-1)</code>；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>,number - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="10-矩阵覆盖"><a href="#10-矩阵覆盖" class="headerlink" title="10.矩阵覆盖"></a>10.矩阵覆盖</h1><p><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&&tqId=11163&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">矩形覆盖_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>本质还是斐波那契。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rectCover</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number &lt;=<span class="number">2</span> ) <span class="keyword">return</span> number;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">rectCover</span>(number - <span class="number">1</span>) + <span class="built_in">rectCover</span>(number - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11.二进制中1的个数"></a>11.二进制中1的个数</h1><p><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&&tqId=11164&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">二进制中1的个数_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一：-5"><a href="#法一：-5" class="headerlink" title="法一："></a>法一：</h3><p>使用库函数<a href="https://www.notion.so/b1b7e2e2f68e468baa103dc6208f8261?pvs=21">bitset</a>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(n).<span class="built_in">count</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二：-4"><a href="#法二：-4" class="headerlink" title="法二："></a>法二：</h3><p>手动位运算。对于n&#x3D;1100，n-1&#x3D;1011。n &amp;&#x3D; n-1后，n&#x3D;1000。这个过程相当于从二进制数中消去了一个1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n &amp;= (n<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12.数值的整数次方"></a>12.数值的整数次方</h1><p><a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&&tqId=11165&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">数值的整数次方_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p><a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">LCR 134. Pow(x, n) - 力扣（LeetCode）</a></p>
<h3 id="法一：-6"><a href="#法一：-6" class="headerlink" title="法一："></a>法一：</h3><p>常规解法，区分正负即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Power</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(base == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            exponent *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;exponent;i++)&#123;</span><br><span class="line">            ans*= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) ans = <span class="number">1</span>/ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二：-5"><a href="#法二：-5" class="headerlink" title="法二："></a>法二：</h3><p>快速幂：把幂次按照二进制拆开，分别计算。例如，计算一个数的10次方相当于计算一个数的1010（二进制）次方，可以看作按照x的2次方一次递增。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Power</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(base == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				<span class="comment">// exp一定要用long。假设exponent=INT_MIN，其对应的正数大于INT_MAX，故不能用int</span></span><br><span class="line">        <span class="type">long</span> exp = exponent;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            exp = exponent *(<span class="number">-1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(exp != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((exp &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                ans *= base;</span><br><span class="line">            &#125;</span><br><span class="line">            base *= base;</span><br><span class="line">            exp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exponent &lt; <span class="number">0</span> ? <span class="number">1</span> /ans : ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13.调整数组顺序使奇数位于偶数前面"></a>13.调整数组顺序使奇数位于偶数前面</h1><p><a href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&&tqId=11166&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">调整数组顺序使奇数位于偶数前面_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一：-7"><a href="#法一：-7" class="headerlink" title="法一："></a>法一：</h3><p>使用辅助数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reOrderArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : array)</span><br><span class="line">            <span class="keyword">if</span>(i &amp; <span class="number">1</span>) array.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : array)</span><br><span class="line">            <span class="keyword">if</span>(!(i &amp; <span class="number">1</span>)) array.<span class="built_in">push_back</span>(i);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),array.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二：-6"><a href="#法二：-6" class="headerlink" title="法二："></a>法二：</h3><p>in-place算法。</p>
<p>用<code>i</code>记录当前需要插入的奇数的位置，用<code>j</code>遍历数组。如果遇到奇数，就将其插入到<code>i</code>所在的位置（<code>i</code>到<code>j-1</code>之间所有的数据往后挪一位）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reOrderArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;array.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> temp = array[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = j<span class="number">-1</span>;k&gt;=i;--k)&#123;</span><br><span class="line">                    array[k+<span class="number">1</span>] = array[k];</span><br><span class="line">                &#125;</span><br><span class="line">                array[i++] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法三："><a href="#法三：" class="headerlink" title="法三："></a>法三：</h3><p>使用STL函数****<code>stable_partition()</code>****对指定区域内的数据进行分组，重新排列指定区域内存储的数据，使其分为两组，第一组位符合筛选条件的数据，另一组为不符合筛选条件的数据。</p>
<p>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> BidirIt, <span class="keyword">class</span> UnaryPredicate &gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BidirIt <span class="title">stable_partition</span><span class="params">( BidirIt first, BidirIt last, UnaryPredicate p )</span></span>;</span><br></pre></td></tr></table></figure>

<p>第三个参数可以传入一个仿函数，函数指针，lambda表达式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reOrderArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stable_partition</span>(array.<span class="built_in">begin</span>(),array.<span class="built_in">end</span>(),[](<span class="type">int</span> x)&#123;<span class="keyword">return</span> x &amp; <span class="number">1</span>;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="14-链表中倒数第k个结点"><a href="#14-链表中倒数第k个结点" class="headerlink" title="14.链表中倒数第k个结点"></a>14.链表中倒数第k个结点</h1><p><a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&&tqId=11167&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">链表中倒数第k个结点_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>双指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="type">unsigned</span> <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!pListHead || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">auto</span> slow = pListHead,fast = pListHead;</span><br><span class="line">		<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(k--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(fast)</span><br><span class="line">				fast = fast-&gt;next;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			 	<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(fast)&#123;</span><br><span class="line">			fast = fast-&gt;next;</span><br><span class="line">			slow = slow-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15.反转链表"></a>15.反转链表</h1><p><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&&tqId=11168&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">反转链表_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一：-8"><a href="#法一：-8" class="headerlink" title="法一："></a>法一：</h3><p>双指针。以1，2，3链表为例，用三个指针，</p>
<ul>
<li>cur指针用来遍历，指向<code>head</code>。</li>
<li>pre指向cur的前一个节点，故一开始其必须初始化为<code>nullptr</code>。</li>
<li>由于在遍历过程中需要将<code>cur-&gt;next</code>指向<code>pre</code>。故还需要一个temp指针用来保存<code>cur-&gt;next</code>实现遍历。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* temp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二：-7"><a href="#法二：-7" class="headerlink" title="法二："></a>法二：</h3><p>递归。一次反转整个链表很困难，但反转第一个元素和第二个元素比较容易。</p>
<ul>
<li>故将原问题可以减小为反转前两个元素。依次往后递归。</li>
<li>在思考时，假定<code>ReverseList(head-&gt;next)</code>代表已经反转好的后续元素。只需要改变链表前两个元素的指针指向并考虑边界条件即可。</li>
<li>边界条件:<code>head == nullptr</code>代表链表本身为空，<code>head-&gt;next == nullptr</code>代表递归出口</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* ans = <span class="built_in">ReverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="16-合并两个有序链表"><a href="#16-合并两个有序链表" class="headerlink" title="16.合并两个有序链表"></a>16.合并两个有序链表</h1><p><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&&tqId=11169&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">合并两个排序的链表_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>经典题目。起一个虚拟头节点，然后一边遍历，一边将小的插在都节点后面，直到两个链表有一个为空。最后将不为空的链表插入到结果的后面即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">if</span>(pHead2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> pHead1;</span><br><span class="line">        ListNode* dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur = dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(pHead1  &amp;&amp; pHead2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = pHead1;</span><br><span class="line">                pHead1 = pHead1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = pHead2;</span><br><span class="line">                pHead2 = pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pHead1) cur-&gt;next = pHead1;</span><br><span class="line">        <span class="keyword">if</span>(pHead2) cur-&gt;next = pHead2;</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="17-树的子结构"><a href="#17-树的子结构" class="headerlink" title="17.树的子结构"></a>17.树的子结构</h1><p><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&&tqId=11170&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">树的子结构_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>树的问题归根结底的递归问题。</p>
<p>根据题意，判断B是不是A的子结构。由于题意表明空树不是任意一个树的子结构，故一开始就将空树进行处理（直接<code>return false</code>）。</p>
<p>之后判断B是否是A的子结构。若B是，则A的任意一个节点都有可能是B的根节点。故需要先序遍历A的每个节点判断以A中的节点node为根节点的子树是否包含树B。（<code>isSameTree</code>）在该函数中，</p>
<ul>
<li>终止条件：<ul>
<li>B为空，表示，B已匹配完成，返回true</li>
<li>A为空，表示已经越过A的叶节点，即匹配失败，返回false</li>
<li>A和B的值不同：表明匹配失败，返回false</li>
</ul>
</li>
<li>返回值：到了最后返回的时候表明A和B的根节点相同，故需要判断其左右子树是否相等。故返回值为<code>isSameTree(pRoot1-&gt;left,pRoot2-&gt;left) &amp;&amp; isSameTree(pRoot1-&gt;right,pRoot2-&gt;right);</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* pRoot1,TreeNode* pRoot2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(pRoot2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span>(pRoot1 == <span class="literal">nullptr</span> || pRoot1-&gt;val != pRoot2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">isSameTree</span>(pRoot1-&gt;left,pRoot2-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(pRoot1-&gt;right,pRoot2-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(pRoot1 == <span class="literal">nullptr</span> || pRoot2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">isSameTree</span>(pRoot1,pRoot2) || <span class="built_in">HasSubtree</span>( pRoot1-&gt;left, pRoot2) || <span class="built_in">HasSubtree</span>(pRoot1-&gt;right,pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18.二叉树的镜像"></a>18.二叉树的镜像</h1><p><a href="https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=265&tqId=39229&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?tpId=13&difficulty=undefined&judgeStatus=undefined&tags=&title=">二叉树的镜像_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>只要能遍历一遍所有节点，然后交换每个节点的左右孩子即可。故三种遍历及其迭代法改造以及层序遍历都可以。</p>
<h3 id="法一：-9"><a href="#法一：-9" class="headerlink" title="法一："></a>法一：</h3><p>理解了递归，就理解了树。这里用先序遍历，先交换节点的左右子节点，之后分别递归处理左右子树。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Mirror</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* temp = pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right = temp;</span><br><span class="line">        <span class="built_in">Mirror</span>(pRoot-&gt;left);</span><br><span class="line">        <span class="built_in">Mirror</span>(pRoot-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二"><a href="#法二" class="headerlink" title="法二:"></a>法二:</h3><p>先序迭代法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Mirror</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* cur = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(cur-&gt;left,cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left) st.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right) st.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法三：-1"><a href="#法三：-1" class="headerlink" title="法三："></a>法三：</h3><p>中序遍历。采用递归实现的中序遍历，部分节点的左右孩子会反转两次。故与传统中序写法不太一致。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Mirror</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">Mirror</span>(pRoot-&gt;left);   <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">swap</span>(pRoot-&gt;left,pRoot-&gt;right);  <span class="comment">//中</span></span><br><span class="line">        <span class="built_in">Mirror</span>(pRoot-&gt;left);  <span class="comment">//“右”，因为左右节点已经交换了，所赐此时的left为原来的right</span></span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="19.顺时针打印矩阵"></a>19.顺时针打印矩阵</h1><p><a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&&tqId=11172&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">顺时针打印矩阵_牛客题霸_牛客网 (nowcoder.com)</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="type">int</span> rl = <span class="number">0</span>, rh = matrix.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> cl = <span class="number">0</span>, ch = matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = cl;i&lt;=ch;i++) ans.<span class="built_in">push_back</span>(matrix[rl][i]);</span><br><span class="line">            <span class="keyword">if</span>(++rl &gt; rh) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = rl;i&lt;=rh;i++) ans.<span class="built_in">push_back</span>(matrix[i][ch]);</span><br><span class="line">            <span class="keyword">if</span>(--ch &lt; cl) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = ch;i &gt;= cl ;i--) ans.<span class="built_in">push_back</span>(matrix[rh][i]);</span><br><span class="line">            <span class="keyword">if</span>(--rh &lt; rl) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = rh;i &gt;= rl;i--) ans.<span class="built_in">push_back</span>(matrix[i][cl]);</span><br><span class="line">            <span class="keyword">if</span>(++cl &gt; ch) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="20-包含min函数的栈"><a href="#20-包含min函数的栈" class="headerlink" title="20.包含min函数的栈"></a>20.包含min函数的栈</h1><p><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&&tqId=11173&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">包含min函数的栈_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一：-10"><a href="#法一：-10" class="headerlink" title="法一："></a>法一：</h3><p>用一个栈，每次存完以后额外存一下最小值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            st.<span class="built_in">push</span>(value);</span><br><span class="line">            st.<span class="built_in">push</span>(value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> mi = st.<span class="built_in">top</span>();</span><br><span class="line">            mi = value &lt; mi ? value : mi;</span><br><span class="line">            st.<span class="built_in">push</span>(value);</span><br><span class="line">            st.<span class="built_in">push</span>(mi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) <span class="keyword">return</span> ;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> temp = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ans = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">push</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-1"><a href="#法二-1" class="headerlink" title="法二"></a>法二</h3><p>也可以用两个栈，一个存数据，另一个存最小值。跟上面原理一样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            st.<span class="built_in">push</span>(value);</span><br><span class="line">            minSt.<span class="built_in">push</span>(value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> mi = minSt.<span class="built_in">top</span>();</span><br><span class="line">            mi = value &lt; mi ? value : mi;</span><br><span class="line">            minSt.<span class="built_in">push</span>(mi);</span><br><span class="line">            st.<span class="built_in">push</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) <span class="keyword">return</span> ;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        minSt.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> minSt.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; minSt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="21-栈的压入、弹出序列"><a href="#21-栈的压入、弹出序列" class="headerlink" title="21.栈的压入、弹出序列"></a>21.栈的压入、弹出序列</h1><p><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&&tqId=11174&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">栈的压入、弹出序列_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>既然是栈的序列，那就用栈模拟。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsPopOrder</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushV, vector&lt;<span class="type">int</span>&gt;&amp; popV)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushV.<span class="built_in">empty</span>() || popV.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;pushV.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            st.<span class="built_in">push</span>(pushV[i]);</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() == popV[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22.从上往下打印二叉树"></a>22.从上往下打印二叉树</h1><p><a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&&tqId=11175&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">从上往下打印二叉树_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>我一个层序遍历就出来了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		queue&lt;TreeNode*&gt; que;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">		<span class="keyword">if</span>(root != <span class="literal">nullptr</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">		<span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			<span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">				TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">				que.<span class="built_in">pop</span>();</span><br><span class="line">				ans.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">				<span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">				<span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>  ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="23-二叉搜索树的后序遍历序列"><a href="#23-二叉搜索树的后序遍历序列" class="headerlink" title="23.二叉搜索树的后序遍历序列"></a>23.二叉搜索树的后序遍历序列</h1><p><a href="https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&&tqId=11176&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">二叉搜索树的后序遍历序列_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一：递归"><a href="#法一：递归" class="headerlink" title="法一：递归"></a>法一：递归</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(sequence,<span class="number">0</span>,sequence.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; sequence,<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> root = sequence[r];</span><br><span class="line">        <span class="type">int</span> j = r - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; sequence[j] &gt; root) j--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i] &gt; root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(sequence,l,j) &amp;&amp; <span class="built_in">check</span>(sequence, j + <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二：-8"><a href="#法二：-8" class="headerlink" title="法二："></a>法二：</h3><ul>
<li>二叉树的中序遍历和后序遍历对应着一种栈的压入、弹出序列。</li>
<li>若是二叉搜索树，对后序遍历序列排序就得到了中序遍历序列。</li>
<li>将中序遍历序列作为入栈序列，检查后续遍历序列是否是一个合法的出栈序列即可（<a href="https://www.notion.so/Offer-c59f1817dfb94c8293859639452b2dda?pvs=21">栈的压入、弹出</a>）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorder</span><span class="params">(sequence)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(inorder.<span class="built_in">begin</span>(),inorder.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isPopOrder</span>(inorder,sequence);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPopOrder</span><span class="params">(vector&lt;<span class="type">int</span>&gt; pushV,vector&lt;<span class="type">int</span>&gt;&amp; popV)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushV.<span class="built_in">empty</span>() || popV.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;pushV.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            st.<span class="built_in">push</span>(pushV[i]);</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp; st.<span class="built_in">top</span>() == popV[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="24-二叉树中和为某一值的路径"><a href="#24-二叉树中和为某一值的路径" class="headerlink" title="24.二叉树中和为某一值的路径"></a>24.二叉树中和为某一值的路径</h1><p><a href="https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&&tqId=11177&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">二叉树中和为某一值的路径(二)_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>回溯法，也是DFS。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bt</span><span class="params">(TreeNode* root,<span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; sum == <span class="number">0</span>)</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="built_in">bt</span>(root-&gt;left,sum);</span><br><span class="line">        <span class="built_in">bt</span>(root-&gt;right,sum);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">FindPath</span>(TreeNode* root, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="built_in">bt</span>(root,target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="25-复杂链表的复制"><a href="#25-复杂链表的复制" class="headerlink" title="25.复杂链表的复制"></a>25.复杂链表的复制</h1><p><a href="https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&&tqId=11178&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">复杂链表的复制_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一：-11"><a href="#法一：-11" class="headerlink" title="法一："></a>法一：</h3><p>将整个复杂过程分为三部。</p>
<ol>
<li>在每个节点后面插入对应的拷贝节点。</li>
<li>遍历一次连表，逐个复制每个原有节点的random指针内容到拷贝节点中。（使用双指针，一个指向原链表的节点，一个指向拷贝链表的节点）</li>
<li>用双指针将链表拆分。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        RandomListNode* cur = pHead;</span><br><span class="line">        <span class="comment">// 每个节点后面新增对应拷贝节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            RandomListNode* temp = <span class="keyword">new</span> <span class="built_in">RandomListNode</span>(cur-&gt;label);</span><br><span class="line">            temp-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = temp;</span><br><span class="line">            cur = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RandomListNode *old = pHead,*clone = pHead-&gt;next,*ret = pHead-&gt;next;</span><br><span class="line">        <span class="comment">// 拷贝random指针内容</span></span><br><span class="line">        <span class="keyword">while</span>(old)&#123;</span><br><span class="line">            clone-&gt;random = old-&gt;random == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : old-&gt;random-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(old-&gt;next) old = old-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(clone-&gt;next) clone = clone-&gt;next-&gt;next; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将链表拆分</span></span><br><span class="line">        old = pHead,clone = pHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(old)&#123;</span><br><span class="line">            <span class="keyword">if</span>(old-&gt;next) old-&gt;next = old-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(clone-&gt;next) clone-&gt;next = clone-&gt;next-&gt;next;</span><br><span class="line">            old = old-&gt;next;</span><br><span class="line">            clone = clone-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-2"><a href="#法二-2" class="headerlink" title="法二"></a>法二</h3><p>本题的复杂之处在于多了一个random指针的复制。next指针的复制十分轻松，但复制之后如何完成random指针的复制是个问题。可以考虑在复制next指针时，用哈希表存储原节点与复制节点的映射。这样只要两次遍历，第一次复制next指针，第二次根据映射关系将原来random的指向映射到新链表上即可完成random指针的复制。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead) <span class="keyword">return</span> pHead;</span><br><span class="line">        RandomListNode* dummy = <span class="keyword">new</span> <span class="built_in">RandomListNode</span>(<span class="number">0</span>);</span><br><span class="line">        RandomListNode* cur = pHead;</span><br><span class="line">        RandomListNode* pre = dummy;</span><br><span class="line">        unordered_map&lt;RandomListNode*, RandomListNode*&gt; mp;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            RandomListNode* temp = <span class="keyword">new</span> <span class="built_in">RandomListNode</span>(cur-&gt;label);</span><br><span class="line">            pre-&gt;next = temp;</span><br><span class="line">            mp[cur] = temp;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [key,value] : mp)&#123;</span><br><span class="line">            value-&gt;random = key-&gt;random == <span class="literal">nullptr</span> ?  <span class="literal">nullptr</span> : mp[key-&gt;random];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="26-二叉搜索树与双向链表"><a href="#26-二叉搜索树与双向链表" class="headerlink" title="26.二叉搜索树与双向链表"></a>26.二叉搜索树与双向链表</h1><p><a href="https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&&tqId=11179&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">二叉搜索树与双向链表_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一：-12"><a href="#法一：-12" class="headerlink" title="法一："></a>法一：</h3><p>先中序遍历二叉树，将其放入一个vector中，然后遍历vector改变指针朝向即可。但这样做在push_back时也属于创建了新的节点，而不是直接改变指针朝向。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	vector&lt;TreeNode*&gt; vec;</span><br><span class="line">	<span class="function"><span class="type">void</span>  <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">		<span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">		vec.<span class="built_in">push_back</span>(root);</span><br><span class="line">		<span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRootOfTree) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="built_in">inorder</span>(pRootOfTree);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;vec.<span class="built_in">size</span>() - <span class="number">1</span>;i++)&#123;</span><br><span class="line">			vec[i]-&gt;right = vec[i + <span class="number">1</span>];</span><br><span class="line">			vec[i+<span class="number">1</span>]-&gt;left = vec[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> vec[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二：-9"><a href="#法二：-9" class="headerlink" title="法二："></a>法二：</h3><p>用一个全局的pre指针记录当前遍历节点的前继节点。</p>
<p>每次递归处理过程中，<code>root-&gt;left = pre。并且pre-&gt;right = root</code>。最后<code>pre = root</code>，更新p<code>re</code>的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRootOfTree) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		TreeNode* ans = pRootOfTree;</span><br><span class="line">		<span class="keyword">while</span>(ans-&gt;left) ans = ans-&gt;left;</span><br><span class="line">		<span class="built_in">inorder</span>(pRootOfTree);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!root) <span class="keyword">return</span> ;</span><br><span class="line">		<span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">		root-&gt;left = pre;</span><br><span class="line">		<span class="keyword">if</span>(pre)&#123;</span><br><span class="line">			pre-&gt;right = root;</span><br><span class="line">		&#125;</span><br><span class="line">		pre = root;</span><br><span class="line">		<span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="27-字符串的排列"><a href="#27-字符串的排列" class="headerlink" title="27.字符串的排列"></a>27.字符串的排列</h1><p><a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=13&&tqId=11180&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">字符串的排列_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一：-13"><a href="#法一：-13" class="headerlink" title="法一："></a>法一：</h3><p>用回溯法，相当于求有重复元素数组的全排列。</p>
<ul>
<li>由于有重复元素，故需要去重</li>
<li>由于求全排列需要用回溯。</li>
<li>递归三部曲：<ol>
<li>递归参数：由于求全排列，故需要用一个数组记录已经访问过的元素，下次递归过来就不访问了。</li>
<li>递归终止条件：当<code>path.size() == str.size()</code>表示str已经遍历完了，就终止。</li>
<li>单层搜索的逻辑：每次都需要从0开始遍历整个str。中间遇到已经访问过的元素，则<code>continue</code>。</li>
</ol>
</li>
<li>去重：由于str中存在重复元素，需要去重。例如”aa”,若不去重，会有<code>[a,a]</code>、<code>[a,a]</code>两种结果。<ul>
<li>去重首先需要将str中各个元素排序。</li>
<li>之后在递归的树形结构中，used记录了是否访问过，str记录了所有数据。如果<code>str[i] == str[i-1]</code>表明需要考虑去重。</li>
<li>若此时，<code>used[i-1] = false</code>表明该在本次全排列计算过程中used[i-1]没有访问过，此时如果继续递归会重复。举例如下：对于<code>[1,1,2]</code>，在以第二个1为首元素时，<code>used[i-1]= false</code>。此时如果继续递归下去，和以第一个1为首元素进行递归的结果会重复。</li>
<li>若此时，<code>used[i-1] = true</code>表明在本次全排列计算时，used[i-1]已经访问过，此时不应去重。举例如下：对于<code>[1,1,2]</code>，表明第一个元素为1，第二个元素为1的情况，此时应该继续递归去寻找第三个元素。<strong>如果此时直接跳过</strong>，得到的全排列中的各个元素之间都是不重复的，这就与题意不符了。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bt</span><span class="params">(string&amp; str,vector&lt;<span class="type">bool</span>&gt;&amp; used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == str.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;<span class="number">0</span> &amp;&amp; str[i] == str[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(str[i]);</span><br><span class="line">            <span class="built_in">bt</span>(str,used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">Permutation</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(str.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">bt</span>(str,used);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二：-10"><a href="#法二：-10" class="headerlink" title="法二："></a>法二：</h3><p>使用STL 中的**<code>next_permutation</code>**返回全排列。该函数必须先排序才能使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">Permutation</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="28-数组中出现次数超过一半的数字"><a href="#28-数组中出现次数超过一半的数字" class="headerlink" title="28.数组中出现次数超过一半的数字"></a>28.数组中出现次数超过一半的数字</h1><p><a href="https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=13&&tqId=11181&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">数组中出现次数超过一半的数字_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一：-14"><a href="#法一：-14" class="headerlink" title="法一："></a>法一：</h3><p>排序后直接返回中间位置的数即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(),numbers.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> numbers[numbers.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>法二：</p>
<p>用哈希表记录一下每个元素有几个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">MoreThanHalfNum_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> &#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(auto&amp; i : numbers)&#123;</span><br><span class="line">            mp[i]++;</span><br><span class="line">            <span class="keyword">if</span>(mp[i] &gt; numbers.size() / <span class="number">2</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>法三：</p>
<p>摩尔投票法：寻找一组元素中占多数的元素的算法。时间复杂度O(n)。</p>
<ul>
<li><strong>基本思想</strong>：每次从序列中选两个不相同的数字删除掉（“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一般的那个。</li>
<li><strong>实现</strong>：<ol>
<li>设置一个计数器遍历时遇到不同数字就-1，遇到相同数字就+1。</li>
<li>只要在计数器归0时，就重新假定当前数字为众数继续遍历。</li>
<li>最后，计数器记录的数字就可能是众数。</li>
<li>最后再遍历一次数组，看看该数出现了几次，或者直接用STL中的count()数一下就好。</li>
<li><em>由于本题确定众数存在，故找到可能的众数后返回即可。</em></li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>,num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;numbers.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;</span><br><span class="line">                num = numbers[i];</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                numbers[i] == num ? cnt++ : cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="29-最小的K个数"><a href="#29-最小的K个数" class="headerlink" title="29.最小的K个数"></a>29.最小的K个数</h1><p><a href="https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&&tqId=11182&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">最小的K个数_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><p>排序之后慢慢数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; input, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(input.<span class="built_in">begin</span>(),input.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-3"><a href="#法二-3" class="headerlink" title="法二"></a>法二</h3><p>用优先队列（小根堆）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; input, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// priority_queue默认为大根堆，故需要用第三个参数指明是小根堆</span></span><br><span class="line">        priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : input) pq.<span class="built_in">push</span>(i);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>());</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="补充：C-中优先队列的用法。"><a href="#补充：C-中优先队列的用法。" class="headerlink" title="补充：C++中优先队列的用法。"></a>补充：C++中优先队列的用法。</h3><ul>
<li>定义：<code>priority_queue&lt;Type, Container, Functional&gt;</code><ul>
<li>Type：数据类型</li>
<li>Container：容器类型，必须是连续存储空间容器，比如vector,deque等，STL默认用vector。</li>
<li>Functional：比较的方式。使用自定义数据类型时需要用该参数表示如何比较类型的大小。使用基本数据类型时，只需要传入数据类型，默认大顶堆。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序队列（小顶堆）</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; pq;</span><br><span class="line"><span class="comment">//降序队列（大顶堆）</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt; pq;</span><br></pre></td></tr></table></figure>

<ul>
<li>greater和less是两个仿函数（使一个类的使用看起来像个函数，就是类中实现了一个<code>operator()</code>）。</li>
</ul>
<h1 id="30-连续子数组的最大和"><a href="#30-连续子数组的最大和" class="headerlink" title="30.连续子数组的最大和"></a>30.连续子数组的最大和</h1><p><a href="https://www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484?tpId=13&&tqId=11183&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">连续子数组的最大和_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一-1"><a href="#法一-1" class="headerlink" title="法一"></a>法一</h3><p>常规dp。<code>dp[i]</code>表示以<code>array[i]</code>结尾的连续子数组的最大和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(array.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ans = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;array.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(array[i],dp[i<span class="number">-1</span>] + array[i]) ;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-4"><a href="#法二-4" class="headerlink" title="法二"></a>法二</h3><p>利用array的空间作为dp数组，减少空间复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;array.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            array[i] = <span class="built_in">max</span>(<span class="number">0</span>,array[i<span class="number">-1</span>]) + array[i];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,array[i]); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法三"><a href="#法三" class="headerlink" title="法三"></a>法三</h3><p>贪心算法。</p>
<ul>
<li>连续子数组的最大值的<strong>贪心原则</strong>是在累加过程中只要中间结果≥0就不中断计数。</li>
<li>例如，<code>4,-1,2</code>中虽然<code>4</code>与<code>-1</code>的和比<code>4</code>小，但其还是正数与之后的<code>2</code>相加时还会贡献一部分数值。</li>
<li>这样做的一个问题是，连续子数组的最大值可能在中间结果产生，例如<code>4，-2，1</code>中最大结果为4，而如果用一个变量来进行累加，该变量的值最后是<code>3</code>。</li>
<li>该问题的解决方案是用一个变量专门记录最大值，在每次累加过程后都更新以下该变量。</li>
</ul>
<p>具体实现而言，可以用一个计数器<code>cnt</code>记录寻找过程中的子数组和。</p>
<p>在累加的过程中，遵循以下规则。</p>
<ol>
<li>当遇到正数或零时，我们直接将其加到计数器 <code>cnt</code> 上，并同时更新记录的最大值。</li>
<li>若遇到负数，需要考虑两种状态<ol>
<li>如果将负数加到当前的累加结果后仍然得到正数，比如 <code>3 + (-2)</code>。此时则将负数加到累加结果上，并继续累加。这是因为这样做有可能对后续的连续子数组结果产生增益。</li>
<li>如果将负数加到当前的累加结果后变成了负数，比如 <code>1 + (-2)</code>。此时，将负数加到当前结果会对之后的连续子数组结果产生负面影响。故将 <code>cnt</code> 清零，重新开始累加。</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;array.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cnt += array[i];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,cnt);</span><br><span class="line">            <span class="keyword">if</span>(cnt &lt; <span class="number">0</span>) cnt = <span class="number">0</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="31-整数中1出现的次数"><a href="#31-整数中1出现的次数" class="headerlink" title="31.整数中1出现的次数"></a>31.整数中1出现的次数</h1><p><a href="https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&&tqId=11184&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">整数中1出现的次数（从1到n整数中1出现的次数）_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一-2"><a href="#法一-2" class="headerlink" title="法一"></a>法一</h3><p>题目怎么说，我就怎么做。主打的就是一个暴力。但数据量一上来就超时了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countOne</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n % <span class="number">10</span> == <span class="number">1</span>) cnt++;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="built_in">countOne</span>(i);</span><br><span class="line">            ans += cnt; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-5"><a href="#法二-5" class="headerlink" title="法二"></a>法二</h3><p>分情况讨论求解吧。1出现的位数为1在n的各个数位上出现的次数之和。</p>
<p><a href="https://blog.csdn.net/huzhigenlaohu/article/details/51779365">剑指offer-整数中1出现的次数（从1到n整数中1出现的次数）-CSDN博客</a></p>
<p>举例如下，</p>
<p>对于<code>n = 1140143</code>，</p>
<ul>
<li>假设base为10，将其分组为<code>high = n / base / 10 = 11401</code> ，<code>cur = n / base % 10 = 4</code>，<code>low = n % base = 3</code>。此时，cur &gt; 1，故1在“十位”上出现的次数有<code>(0~11401)x(0~9)</code>即<code>(high + 1)*base</code>。</li>
<li>假设base为100，将其分组为<code>high = n / base / 10 = 1140</code> ，<code>cur = n / base % 10 = 1</code>，<code>low = n % base = 43</code>。此时，cur &#x3D;&#x3D; 1，故1出现的次数需要分情况讨论<ul>
<li>当high为<code>（0~1139）</code>时，low依旧可以在<code>（0~99）</code>中间任意选择。故1出现的次数为<code>high * base</code></li>
<li>当high为1140时，low必须在<code>(0~low)</code>中间选择。否则结果会大于n。故1出现的次数为<code>low + 1</code>。</li>
<li>综合两种情况，此时1在“百位”上出现的次数为<code>high * base + (low + 1)</code></li>
</ul>
</li>
<li>假设base为1000，将其分组为<code>high = n / base / 10 = 114</code> ，<code>cur = n / base % 10 = 0</code>，<code>low = n % base = 143</code>。此时，high只能在<code>(0~113)</code>中选择，base可以在<code>(0~999)</code>中选择。故1在“千位”上出现的次数为<code>high * base</code>。</li>
</ul>
<p>最后只要将base从1到n走一遍，就将所有情况统计全了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> base = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(base &lt;= n)&#123;</span><br><span class="line">            <span class="type">int</span> low = n % base;</span><br><span class="line">            <span class="type">int</span> high = n / base;</span><br><span class="line">            <span class="type">int</span> cur = high % <span class="number">10</span>;</span><br><span class="line">            high /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                ans += (high + <span class="number">1</span>) * base;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur == <span class="number">1</span>)&#123;</span><br><span class="line">                ans += high * base + (low + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">                ans += high * base;</span><br><span class="line">            &#125;</span><br><span class="line">            base *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法三-1"><a href="#法三-1" class="headerlink" title="法三"></a>法三</h3><p>与法二相似，还是逐位统计1的个数，但是从最高位开始分段处理。</p>
<p>例如对于1145。最高位为<code>high = 1</code>，最高位权重为<code>base = 1000</code>。</p>
<ul>
<li>最高位是1<ul>
<li>最高位1的次数为<code>last + 1</code>（1000-1145），这里对于（1000-1145）只计算其千位上的1，（000~145）这三位上的留在之后计算。</li>
<li>去除最高位的次数，0-999的1的个数为<code>high*NumberOf1Between1AndN_Solution(base - 1)</code></li>
<li>剩余部分1的个数为<code>NumberOf1Between1AndN_Solution(last)</code>（这部分为145中1的个数，但与0-999中的不冲突，因为此时的代表最高位为1时，剩余部分1的个数）</li>
</ul>
</li>
<li>最高位不是1，例如是2<ul>
<li>最高位1的次数为<code>base</code>(1000-1999)</li>
<li>去除最高位的次数，即0-999，1000-1999<code>high*NumberOf1Between1AndN_Solution(pow - 1)</code></li>
<li>剩余部分1的个数为<code>NumberOf1Between1AndN_Solution(last)</code></li>
</ul>
</li>
</ul>
<p>以上两种情况的差别仅在于最高位1的次数。故可以合并处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">10</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> high = n,base = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(high &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">            high /= <span class="number">10</span>;</span><br><span class="line">            base *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> last = n - high * base;</span><br><span class="line">        <span class="type">int</span> cnt = high == <span class="number">1</span> ? last + <span class="number">1</span> : base;</span><br><span class="line">        <span class="keyword">return</span> cnt + high*<span class="built_in">NumberOf1Between1AndN_Solution</span>(base - <span class="number">1</span>) + <span class="built_in">NumberOf1Between1AndN_Solution</span>(last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="32-把数组排成最小的数"><a href="#32-把数组排成最小的数" class="headerlink" title="32.把数组排成最小的数"></a>32.把数组排成最小的数</h1><p><a href="https://www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993?tpId=13&&tqId=11185&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">把数组排成最小的数_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>该问题所求其实就是数组中<strong>各个数字如何排列拼接而成的字符串表示的值最小</strong>。对于a和b两个数，如果ab大于ba那么a一定在b前面。</p>
<p>例如，<code>a=12</code>,<code>b = 34</code>。则<code>ab=1234</code>,<code>ba=3412</code>，最终排列时b一定在a前面。</p>
<p>故，可以数自定义一种比较方式利用sort实现排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">PrintMinNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        vector&lt;string&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : numbers)&#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(num));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),[](string&amp; a,string&amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b &lt; b + a;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)&#123;</span><br><span class="line">            ans += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注：若sort函数的第三个参数不使用lambda表达式而使用比较函数，该函数需要定义为静态函数。</p>
<p>这是因为在类内定义的非static成员函数在经过编译后会隐式添加一个this指针参数，而标准库的sort()函数的第三个cmp函数指针参数中并没有这样this指针参数，因此会出现输入的cmp参数和sort()要求的参数不匹配，从而导致了：<code>error: reference to non-static member function must be called</code>。</p>
<p>正确写法如下，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(string&amp; a,string &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b &lt; b + a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">PrintMinNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        vector&lt;string&gt; nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : numbers)&#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(<span class="built_in">to_string</span>(num));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums)&#123;</span><br><span class="line">            ans += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="33-第N个丑数"><a href="#33-第N个丑数" class="headerlink" title="33.第N个丑数"></a>33.第N个丑数</h1><p><a href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=13&&tqId=11186&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">丑数_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一-3"><a href="#法一-3" class="headerlink" title="法一"></a>法一</h3><p>三指针法。</p>
<p>丑数就是只包含质因子2、3、5的数。</p>
<ul>
<li>从1开始逐个判断是否为丑数是一个直观的解决方案。具体而言，可以依次检查能否被2、3、5整除。如果能被2整除，则除以2；如果能被3整除，则除以3；最后，如果剩下的是1，那么就是丑数，否则不是。</li>
<li>上面的重复计算很多。比如，假设我们知道4是丑数，8首先除以2得到4之后完全没必要继续除下去了，可以得到8也是丑数的结果。故，可以用空间换时间。<ul>
<li>只计算丑数，根据定义。丑数应该是一个丑数乘以2、3、5得到的结果（1除外）。但在乘的过程中如何保证得到的一系列丑数是有序的方便我们找到第N个呢？</li>
<li>用三个指针分别指向当前乘以2、3、5的丑数，初始值都为0，代表第0个丑数1。例如，indexThree &#x3D; 2表示，第二个丑数乘以3。</li>
<li>每次循环中，从三个指针的计算结果中选出最小的一个作为新的丑数，并将对应的指针加1，表示下次用更大的丑数乘以相应的因子。例如，第一次循环中，最小的丑数为2，所以将indexTwo加1，表示下次用第二个丑数2乘以2。</li>
<li>这样便可以得到一个有序的丑数序列。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">7</span>) <span class="keyword">return</span> index;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(index)</span></span>;</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> indexTwo = <span class="number">0</span>,indexThree = <span class="number">0</span>,indexFive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;index;++i)&#123;</span><br><span class="line">            <span class="type">int</span> minNum = <span class="built_in">min</span>(<span class="built_in">min</span>(ans[indexTwo] * <span class="number">2</span>,ans[indexThree] * <span class="number">3</span>),ans[indexFive]* <span class="number">5</span>);</span><br><span class="line">            <span class="keyword">if</span>(minNum == ans[indexTwo] * <span class="number">2</span>) indexTwo++;</span><br><span class="line">            <span class="keyword">if</span>(minNum == ans[indexThree] * <span class="number">3</span>) indexThree++;</span><br><span class="line">            <span class="keyword">if</span>(minNum == ans[indexFive] * <span class="number">5</span>) indexFive++;</span><br><span class="line">            ans[i] = minNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans[index - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-6"><a href="#法二-6" class="headerlink" title="法二"></a>法二</h3><p>小顶堆 + 哈希表</p>
<ol>
<li>用小顶堆记录丑数，用哈希表去重，数组记录2、3、5乘数因子。</li>
<li>1作为第一个丑数先入堆，后面的丑数都是其不断乘以2、3、5的结果。</li>
<li>每次从小顶堆中弹出最小的元素，一共弹出index次。</li>
<li>对于每个弹出的元素，用其构造后面的丑数，即分别乘以2、3、5，若是不重复，则加入堆中。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; fac = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        priority_queue&lt;<span class="type">long</span> <span class="type">long</span>,vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;,greater&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; pq;</span><br><span class="line">        unordered_set&lt;<span class="type">long</span> <span class="type">long</span>&gt; st;</span><br><span class="line">        <span class="comment">// 放入初始丑数1</span></span><br><span class="line">        st.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">        pq.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            ans = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> next = ans * fac[j];</span><br><span class="line">                <span class="keyword">if</span>(st.<span class="built_in">find</span>(next) == st.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    st.<span class="built_in">insert</span>(next);</span><br><span class="line">                    pq.<span class="built_in">push</span>(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>在计算过程中会有数超过int范围，故哈希表和小根堆都要用long long。那么为什么法一不需要呢？<ul>
<li>因为法一乘数因子是各自独立乘以属于自己的当前丑数。</li>
<li>而法二是找一个最小的丑数然后分别乘以2、3、5。</li>
<li>这时候就可能遇见这种情况：需要求第7个丑数，但是在第4个丑数乘以5的时候已经求到了第9个丑数，虽然第7个丑数还是int的范围内，但第9个丑数已经超过int的范围了。</li>
</ul>
</li>
</ul>
<h1 id="34-第一个只出现一次的字符"><a href="#34-第一个只出现一次的字符" class="headerlink" title="34.第一个只出现一次的字符"></a>34.第一个只出现一次的字符</h1><p><a href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&&tqId=11187&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">第一个只出现一次的字符_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一-4"><a href="#法一-4" class="headerlink" title="法一"></a>法一</h3><p>题目中说字符串只由字母组成，故不需要用哈希表来存储，直接用一个数组来充当一个简易的哈希表。所有的字母中ASCII码最小的是A（65），最大的是z（122），故需要一个大小为122-65+1&#x3D;58的数组来记录这些字符出现的次数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">58</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s : str)</span><br><span class="line">            vec[s - <span class="string">&#x27;A&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[str[i] - <span class="string">&#x27;A&#x27;</span>] == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-7"><a href="#法二-7" class="headerlink" title="法二"></a>法二</h3><p>如果记不清ASCII码最小的字符是A还是a，直接用哈希表来存也是一样的，只需要一个简单的替换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s : str)</span><br><span class="line">            mp[s]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;str.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[str[i]] == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="35-数组中的逆序对"><a href="#35-数组中的逆序对" class="headerlink" title="35.数组中的逆序对"></a>35.数组中的逆序对</h1><p><a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&&tqId=11188&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">数组中的逆序对_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一-5"><a href="#法一-5" class="headerlink" title="法一"></a>法一</h3><p>直接暴力，果不其然超时了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">InversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[i])&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    ans %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-8"><a href="#法二-8" class="headerlink" title="法二"></a>法二</h3><p>归并排序与逆序对息息相关。</p>
<p>求nums的逆序对时，将nums从中间分为两部分。故nums的逆序对&#x3D;（1）左半数组的逆序对 + （2）右半数组逆序对 + （3）左右两边的逆序对（右边数组中的数&lt;左边数组时）。</p>
<ul>
<li>其中（1）和（2）可以直接递归去算，直到递归出口（数组中只有一个元素，逆序对为0）。</li>
<li>（3）则需要在归并左右两个数组时进行计算。设排序时，左右两个数组当前索引分别为<code>i，j</code>，中间值为<code>mid</code>。此时只有<code>j</code>处的元素 &lt; <code>i</code>处的元素时，会产生逆序对（从<code>i</code>开始到<code>mid</code>处，即<code>mid - i + 1</code>个）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">InversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">copy</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MergeSort</span>(nums,copy,<span class="number">0</span>,nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; data,vector&lt;<span class="type">int</span>&gt;&amp; copy,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 递归出口数组只有一个元素，不存在逆序对</span></span><br><span class="line">        <span class="comment">// 递归，分为左右两组分别归并</span></span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">MergeSort</span>(data, copy, left, mid )+ <span class="built_in">MergeSort</span>(data, copy, mid + <span class="number">1</span>, right);</span><br><span class="line">        ans %= MOD;</span><br><span class="line">        <span class="comment">// 合并</span></span><br><span class="line">        <span class="type">int</span> i = left,j = mid + <span class="number">1</span>; <span class="comment">// 左右两个排好序的子数组的起始索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = left;k&lt;=right;k++) copy[k] = data[k]; <span class="comment">//暂时记录[left,right]间的顺序，开始合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = left;k&lt;=right;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == mid + <span class="number">1</span>) data[k] = copy[j++]; <span class="comment">// 左边数组合并完了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == right + <span class="number">1</span>) data[k] = copy[i++]; <span class="comment">// 右边数组合并完了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(copy[i] &lt;= copy[j]) data[k] = copy[i++]; <span class="comment">// 左边数组当前值&lt;=右边数组</span></span><br><span class="line">            <span class="keyword">else</span>&#123;       <span class="comment">// 左边数组当前值大于右边数组</span></span><br><span class="line">                data[k] = copy[j++];</span><br><span class="line">                ans += (mid - i + <span class="number">1</span>);  <span class="comment">// 将右边数组当前值归位时，增加了 mid - i + 1个逆序对（左边数组剩余元素）</span></span><br><span class="line">                ans %= MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法三-2"><a href="#法三-2" class="headerlink" title="法三"></a>法三</h3><ul>
<li>法二在合并两个数组的过程中，设计到很多数据交换。例如，首先要将数据从data写入到copy，然后一边排序一边写回data。</li>
<li>可以换一种思路实现，每次都将data中的数据排序后写入到copy。</li>
<li>该方法交换次数减少，但可读性降低，慎用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">InversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">copy</span><span class="params">(nums)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MergeSort</span>(nums,copy,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; data,vector&lt;<span class="type">int</span>&gt;&amp; copy,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">MergeSort</span>(copy, data, left, mid) + <span class="built_in">MergeSort</span>(copy,data, mid + <span class="number">1</span>, right);</span><br><span class="line">        ans %= MOD;</span><br><span class="line">        <span class="type">int</span> i = left,j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = left;k&lt;=right;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == mid + <span class="number">1</span>) copy[k] = data[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == right + <span class="number">1</span> || data[i] &lt;= data[j]) copy[k] = data[i++];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                copy[k] = data[j++];</span><br><span class="line">                ans += (mid + <span class="number">1</span> - i);</span><br><span class="line">                ans %= MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>data理解为原有乱序数组，copy理解为排好序的数组，归并过程就是要将data中的数据排序后放在copy中。即该法的思路是将data中的数据排序后放在copy中，表现在代码中就是与法二相比归并过程中<strong>copy成为了左值</strong>。</li>
<li>在每一次递归调用中，<code>data</code> 和 <code>copy</code> 两个数组的角色在递归间调换。一个数组在一次递归中作为源数组，而在下一次递归中作为目标数组。这样，每一次递归都是将有序的部分从一个数组复制到另一个数组中，而无需进行元素的实际交换。</li>
<li>由于该方法中copy数组不需要一次次的交换数据，故一开始其数据必须和nums一致。<code>vector&lt;int&gt; copy(nums);</code>不可以用  <code>vector&lt;int&gt; copy(nums.size());</code>代替。</li>
<li><code>MergeSort(copy, data, left, mid)</code>该函数中copy与data<strong>参数交换</strong>了一下。</li>
<li><code>if(j == right + 1 || data[i] &lt;= data[j])</code>由于两个条件的执行语句一样将其放在一起写了。</li>
</ul>
<h1 id="36-两个链表的第一个公共结点"><a href="#36-两个链表的第一个公共结点" class="headerlink" title="36.两个链表的第一个公共结点"></a>36.两个链表的第一个公共结点</h1><p><a href="https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&&tqId=11189&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">两个链表的第一个公共结点_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一-6"><a href="#法一-6" class="headerlink" title="法一"></a>法一</h3><p>需要找的是公共节点（该节点之后两条链表变为一条），要与值相同的链表区分。</p>
<ol>
<li>计算两条链表的长度，cnt1和cnt2。</li>
<li>将两条链表末尾对齐，（长的链表往后走diff（<code>|cnt1 - cnt2|</code>）步）。因为如果存在公共节点的话一定是从一个交汇节点到链表末尾都一样。</li>
<li>开始遍历对齐后的链表，找到一样的返回，找不到表示不存在。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">		ListNode* cur1 = pHead1;</span><br><span class="line">		ListNode* cur2 = pHead2;</span><br><span class="line">		<span class="type">int</span> cnt1 = <span class="number">0</span>,cnt2 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(cur1)&#123;</span><br><span class="line">			cur1 = cur1-&gt;next;</span><br><span class="line">			cnt1++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(cur2)&#123;</span><br><span class="line">			cur2 = cur2-&gt;next;</span><br><span class="line">			cnt2++;</span><br><span class="line">		&#125;</span><br><span class="line">		cur1 = pHead1,cur2 = pHead2;</span><br><span class="line">		<span class="keyword">if</span>(cnt1 &lt; cnt2)&#123;</span><br><span class="line">			<span class="built_in">swap</span>(cur1,cur2);</span><br><span class="line">			<span class="built_in">swap</span>(cnt1,cnt2);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> diff = cnt1 - cnt2;</span><br><span class="line">		<span class="keyword">while</span>(diff--) cur1 = cur1-&gt;next;</span><br><span class="line">		<span class="keyword">while</span>(cur1 &amp;&amp; cur2)&#123;</span><br><span class="line">			<span class="keyword">if</span>(cur1 == cur2) <span class="keyword">return</span> cur1;</span><br><span class="line">			cur1 = cur1-&gt;next;</span><br><span class="line">			cur2 = cur2-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-9"><a href="#法二-9" class="headerlink" title="法二"></a>法二</h3><p>该题最大的问题是在于两条链表的长度可能不同，</p>
<ul>
<li>若两条链表长度相同，则一个循环直接边遍历边比较即可，找不到就是不存在。</li>
<li>若长度不同，可以在指针到了链表结尾后指向另一条链表的头。这样便抹平了长度差（两个链表上的所有元素都要被指针走一趟），这样结束的时候要么两个指针都指向nullptr，要么都指向公共节点。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode* cur1 = pHead1;</span><br><span class="line">				ListNode* cur2 = pHead2;</span><br><span class="line">				<span class="keyword">while</span>(cur1 != cur2)&#123;</span><br><span class="line">					cur1 = (cur1 == <span class="literal">nullptr</span> ? pHead2 : cur1-&gt;next);</span><br><span class="line">					cur2 = (cur2 == <span class="literal">nullptr</span> ? pHead1 : cur2-&gt;next);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> cur1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="37-统计一个数字在排序数组中出现的次数"><a href="#37-统计一个数字在排序数组中出现的次数" class="headerlink" title="37.统计一个数字在排序数组中出现的次数"></a>37.统计一个数字在排序数组中出现的次数</h1><p><a href="https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=13&&tqId=11190&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">数字在升序数组中出现的次数_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一-7"><a href="#法一-7" class="headerlink" title="法一"></a>法一</h3><p>很直接的想法，题目怎么说，我就怎么来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetNumberOfK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == k) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-10"><a href="#法二-10" class="headerlink" title="法二"></a>法二</h3><p>由于是非降序数组，可以利用二分法寻找k的后一个元素和k的前一个元素的索引位置，两者相减就是k出现的次数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; data,<span class="type">float</span> k)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = data.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(data[mid] &lt; k) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetNumberOfK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BinarySearch</span>(nums,k + <span class="number">0.5</span>) - <span class="built_in">BinarySearch</span>(nums,k - <span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>自己写的二分查找中k需要用浮点数，否则无法通过加减0.5找到与k相连的元素。</li>
<li>二分查找过程中不需要考虑<code>data[mid]==k</code>，因为k一定不是整数，而data数组里都是整数，两者不会相等。</li>
<li>BinarySearch返回值返回<code>left</code>和<code>right</code>都可。因为所求结果是一个差值，而不是一个精确的位置，在跳出while循环时，right永远比left大1。</li>
</ul>
<h1 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38.二叉树的深度"></a>38.二叉树的深度</h1><p><a href="https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&&tqId=11191&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">二叉树的深度_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一-8"><a href="#法一-8" class="headerlink" title="法一"></a>法一</h3><p>树的问题归根结底就是遍历问题，求深度可以用层序遍历，遍历一层cnt加一即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		queue&lt;TreeNode*&gt; que;</span><br><span class="line">		<span class="keyword">if</span>(pRoot != <span class="literal">nullptr</span>) que.<span class="built_in">push</span>(pRoot);</span><br><span class="line">		<span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			<span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">				TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">				que.<span class="built_in">pop</span>();</span><br><span class="line">				<span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">				<span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-11"><a href="#法二-11" class="headerlink" title="法二"></a>法二</h3><p>递归的逻辑也很容易梳理出来</p>
<p>递归出口为根节点为0，return 0。</p>
<p>递归公式为，一棵树的深度等于左右子树的最大深度 + 1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">TreeDepth</span>(pRoot-&gt;left),<span class="built_in">TreeDepth</span>(pRoot-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="39-判断是不是平衡二叉树"><a href="#39-判断是不是平衡二叉树" class="headerlink" title="39.判断是不是平衡二叉树"></a>39.判断是不是平衡二叉树</h1><p><a href="https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&&tqId=11192&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">判断是不是平衡二叉树_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一-9"><a href="#法一-9" class="headerlink" title="法一"></a>法一</h3><p>一个很直观的想法就是递归。平衡二叉树就是任何子树的左右子树之间的深度差小于等于1。结合38题的代码，遍历一遍节点看看是否符合条件即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MaxDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">MaxDepth</span>(root-&gt;left),<span class="built_in">MaxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="built_in">MaxDepth</span>(root-&gt;left) - <span class="built_in">MaxDepth</span>(root-&gt;right)) &lt;= <span class="number">1</span> &amp;&amp; <span class="built_in">IsBalanced_Solution</span>(root-&gt;left) &amp;&amp; <span class="built_in">IsBalanced_Solution</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-12"><a href="#法二-12" class="headerlink" title="法二"></a>法二</h3><p>法一的冗余计算太多了，在遍历上层节点时会多次重复遍历下层的节点。可以更换一种遍历方式，由下往上遍历。遍历过程中，若该子树的平衡树返回树的深度，不是则返回-1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">GetDepth</span>(root-&gt;left);   <span class="comment">// 左</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 左子树不是平衡树</span></span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">GetDepth</span>(root-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">if</span>(right == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 右子树不是平衡树</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//不是平衡树，中</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right) + <span class="number">1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">GetDepth</span>(root)!= <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40.数组中只出现一次的数字"></a>40.数组中只出现一次的数字</h1><p><a href="https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=13&&tqId=11193&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">数组中只出现一次的数字_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一-10"><a href="#法一-10" class="headerlink" title="法一"></a>法一</h3><p>初看此题有点惊讶，因为要找到两个数字，而c++不能直接返回两个数，所以给定参数采用了两个指针来保存结果，这也是需要返回多个结果时的一种常见方式。</p>
<p>第一印象还是直接按照题目说的来，题目怎么说我就怎么写。遍历一遍数一数每个数字出现了几次，然后再遍历一次，数两个只出现一次的就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(vector&lt;<span class="type">int</span>&gt; data,<span class="type">int</span>* num1,<span class="type">int</span> *num2)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : data) mp[num]++;</span><br><span class="line">        <span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span>(it != mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second == <span class="number">1</span>)&#123;</span><br><span class="line">                *num1 = it-&gt;first;</span><br><span class="line">                it++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(it != mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second == <span class="number">1</span>)&#123;</span><br><span class="line">                *num2 = it-&gt;first;</span><br><span class="line">                it++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-13"><a href="#法二-13" class="headerlink" title="法二"></a>法二</h3><p>A ^ A &#x3D; 0，所以如果只有一个数字出现了一次的话，直接把数组中的数全异或一次就得到结果了。但该题里右两个那么全异或一次，得到的结果就是A ^ B。该数的1表示A与B不同的位，0表示相同的位。</p>
<p>所以，可以知道A和B的哪一位是不同的。根据这一点将数组分为两组。每组里面自己全部异或一遍得到的就是两个不同的数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(vector&lt;<span class="type">int</span>&gt; data,<span class="type">int</span>* num1,<span class="type">int</span> *num2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> totalNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : data) totalNum ^= num;</span><br><span class="line">        <span class="type">int</span> sign = <span class="number">0</span>;</span><br><span class="line">				<span class="comment">// get A ^ B</span></span><br><span class="line">        <span class="keyword">while</span>(totalNum)&#123;</span><br><span class="line">            <span class="keyword">if</span>(totalNum &amp; (<span class="number">1</span> &lt;&lt; sign)) <span class="keyword">break</span>;</span><br><span class="line">            sign++;</span><br><span class="line">        &#125;</span><br><span class="line">        num1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        num2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i :  data)&#123;   <span class="comment">// 分组异或</span></span><br><span class="line">            <span class="keyword">if</span>(i &amp; (<span class="number">1</span> &lt;&lt; sign))&#123;</span><br><span class="line">                num1[<span class="number">0</span>] ^= i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num2[<span class="number">0</span>] ^= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="41-和为S的连续正数序列"><a href="#41-和为S的连续正数序列" class="headerlink" title="41.和为S的连续正数序列"></a>41.和为S的连续正数序列</h1><p><a href="https://www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe?tpId=13&&tqId=11194&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">和为S的连续正数序列_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一-11"><a href="#法一-11" class="headerlink" title="法一"></a>法一</h3><p>暴力数一数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">FindContinuousSequence</span>(<span class="type">int</span> sum) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= sum / <span class="number">2</span>  ;i++)&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i ;j &lt; sum ;j++ )&#123;</span><br><span class="line">                temp += j;</span><br><span class="line">                vec.<span class="built_in">push_back</span>(j);</span><br><span class="line">                <span class="keyword">if</span>(temp == sum)&#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(vec);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-14"><a href="#法二-14" class="headerlink" title="法二"></a>法二</h3><p>滑动窗口</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">FindContinuousSequence</span>(<span class="type">int</span> sum) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">1</span>, high = <span class="number">2</span>;  <span class="comment">// 初始窗口</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="type">int</span> temp = (low + high) * (high - low + <span class="number">1</span>) / <span class="number">2</span>;  <span class="comment">//等差数列求和公式，（首项 + 尾项）* 项数 / 2</span></span><br><span class="line">            <span class="keyword">if</span>(temp == sum)&#123;  <span class="comment">// 窗口内正好是符合条件的一列数</span></span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = low;i&lt;=high;i++) vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">                ans.<span class="built_in">push_back</span>(vec);</span><br><span class="line">                low++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp &lt; sum)&#123;  <span class="comment">// 窗口内值太小，需要大一点，所以窗口右端右移动</span></span><br><span class="line">                high++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;   <span class="comment">// 窗口太大，需要小一点，就窗口左端左移，减少一个数</span></span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="42-和为S的两个数字"><a href="#42-和为S的两个数字" class="headerlink" title="42.和为S的两个数字"></a>42.和为S的两个数字</h1><p><a href="https://www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b?tpId=13&&tqId=11195&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">和为S的两个数字_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一-12"><a href="#法一-12" class="headerlink" title="法一"></a>法一</h3><p>经典两数之和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FindNumbersWithSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; array,<span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : array)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">find</span>(sum - num) != st.<span class="built_in">end</span>()) <span class="keyword">return</span> &#123;num,sum - num&#125;;</span><br><span class="line">            st.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-15"><a href="#法二-15" class="headerlink" title="法二"></a>法二</h3><p>由于是升序数据，可以利用滑动窗口。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FindNumbersWithSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; array,<span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = array.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            <span class="type">int</span> temp = array[low] + array[high]; </span><br><span class="line">            <span class="keyword">if</span>( temp == sum) <span class="keyword">return</span> &#123;array[low],array[high]&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp &lt; sum) low++;</span><br><span class="line">            <span class="keyword">else</span> high--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="43-左旋转字符串"><a href="#43-左旋转字符串" class="headerlink" title="43.左旋转字符串"></a>43.左旋转字符串</h1><p><a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&&tqId=11196&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">左旋转字符串_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一-13"><a href="#法一-13" class="headerlink" title="法一"></a>法一</h3><p>经典方法，三次反转。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">LeftRotateString</span><span class="params">(string str, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || str.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> str; </span><br><span class="line">        n = n % str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">begin</span>() + n);</span><br><span class="line">        <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>()+ n ,str.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-16"><a href="#法二-16" class="headerlink" title="法二"></a>法二</h3><p>拼接以后，直接截取后半部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">LeftRotateString</span><span class="params">(string str, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> str;</span><br><span class="line">        n %= len;</span><br><span class="line">        str += str;</span><br><span class="line">        <span class="keyword">return</span> str.<span class="built_in">substr</span>(n,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="44-反转单词序列"><a href="#44-反转单词序列" class="headerlink" title="44.反转单词序列"></a>44.反转单词序列</h1><h3 id="法一-14"><a href="#法一-14" class="headerlink" title="法一"></a>法一</h3><p>题目怎么说，我就怎么写。说是反转，我就直接倒着数。不过倒过来倒过去的看顺序还是有点麻烦。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">ReverseSentence</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        string ans,temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = str.<span class="built_in">size</span>() - <span class="number">1</span>; i&gt;=<span class="number">0</span> ;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                ans = ans + temp + <span class="string">&quot; &quot;</span>;</span><br><span class="line">                temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp = str[i] + temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.<span class="built_in">size</span>()) ans += temp;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-17"><a href="#法二-17" class="headerlink" title="法二"></a>法二</h3><p>看到反转，倒叙可以想到栈；然后单词之间是用空格分割的可以想到利用流的特性完成句子的分割。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">ReverseSentence</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="function">istringstream <span class="title">is</span><span class="params">(str)</span></span>;</span><br><span class="line">        stack&lt;string&gt; st;</span><br><span class="line">        <span class="keyword">while</span>(is&gt;&gt;temp)&#123;</span><br><span class="line">            st.<span class="built_in">push</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            temp = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            ans += temp;</span><br><span class="line">            ans += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">substr</span>(<span class="number">0</span>,ans.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法三-3"><a href="#法三-3" class="headerlink" title="法三"></a>法三</h3><p>其实，如果是python或者JAVA可以直接用split分割之后整体反转一下再加起来就行了。C++没有split可以自己手搓一个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string&amp; input,<span class="type">const</span> <span class="type">char</span>&amp; reg)</span></span>&#123;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(input)</span></span>;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        string token;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(ss,token,reg))&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">ReverseSentence</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; vec = <span class="built_in">split</span>(str,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; s : vec)&#123;</span><br><span class="line">            ans += s;</span><br><span class="line">            ans += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.<span class="built_in">substr</span>(<span class="number">0</span>,ans.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="45-扑克牌顺子"><a href="#45-扑克牌顺子" class="headerlink" title="45.扑克牌顺子"></a>45.扑克牌顺子</h1><p><a href="https://www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4?tpId=13&&tqId=11198&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">扑克牌顺子_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一-15"><a href="#法一-15" class="headerlink" title="法一"></a>法一</h3><p>顺子的特点：</p>
<ul>
<li>除了0以外，不能有相同的牌。</li>
<li>两张牌之间的间隔必须为1，如果不为1需要用0补齐。需要补的0的个数记为inner。</li>
<li>如果0的个数小于inner，则可以补成顺子，否则不行。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsContinuous</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(),numbers.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> zero = <span class="number">0</span>, inner = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i&lt;numbers.<span class="built_in">size</span>() - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == <span class="number">0</span>) zero++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i] == numbers[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                inner += numbers[i + <span class="number">1</span>] - numbers[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(zero &lt; inner) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>虽然顺子里只有两张王（只有两个0），但有个样例是<code>[1,0,0,5,0]</code>如果输出为false无法通过。所以代码中不需要添加对0个数是否小于2的判断。</li>
<li>ps. 以前做过一次类似的，通过率一直差一点百思不得其解，做这个的时候突然顿悟，当时没想到不能有重复的牌。</li>
</ul>
<h3 id="法二-18"><a href="#法二-18" class="headerlink" title="法二"></a>法二</h3><p>原理同上，换种写法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsContinuous</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(),numbers.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(numbers[i] == <span class="number">0</span>) zero++, i++;</span><br><span class="line">        <span class="type">int</span> inner = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;numbers.<span class="built_in">size</span>() - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == numbers[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            inner += numbers[i + <span class="number">1</span>] - numbers[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(zero &lt; inner) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="46-孩子们的游戏-圆圈中最后剩下的数"><a href="#46-孩子们的游戏-圆圈中最后剩下的数" class="headerlink" title="46.孩子们的游戏(圆圈中最后剩下的数)"></a>46.孩子们的游戏(圆圈中最后剩下的数)</h1><p><a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&&tqId=11199&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">孩子们的游戏(圆圈中最后剩下的数)_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一-16"><a href="#法一-16" class="headerlink" title="法一"></a>法一</h3><p>题目怎么说，那就怎么写。</p>
<ul>
<li>n个人就搞一个容量为n的数组。</li>
<li>每m个重新开始报数，也需要一个变量来记录是否到了m个。到了的话，就把<code>vec[m]</code>设为<code>-1</code>表示孩子出局了。</li>
<li>报数就用一个<code>i</code>变量来记录，如果<code>vec[i]==-1</code>表示这个孩子出局了，直接跳过。由于要从0开始报数，所以<code>i</code>初始化为1。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">-1</span> ,cnt = n;</span><br><span class="line">        <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= vec.<span class="built_in">size</span>()) i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(vec[i] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            step++;</span><br><span class="line">            <span class="keyword">if</span>(step == m)&#123;</span><br><span class="line">                vec[i] = <span class="number">-1</span>;</span><br><span class="line">                step = <span class="number">0</span>;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-19"><a href="#法二-19" class="headerlink" title="法二"></a>法二</h3><p>利用约瑟夫环的公式。</p>
<p><a href="https://www.cnblogs.com/very-beginning/p/11991693.html">约瑟夫问题–五种变式 - 小又又</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            pos = (pos + m) % i;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="47-求1-2-3-…-n"><a href="#47-求1-2-3-…-n" class="headerlink" title="47.求1+2+3+…+n"></a>47.求1+2+3+…+n</h1><p><a href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId=13&&tqId=11200&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">求1+2+3+…+n_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>初看好简单，仔细一看不能使用乘除和判断，也就是说只能用加法和条件判断，故不能用求和公式，那就基本只能用位运算进行条件判断了。</p>
<ul>
<li>原式 &#x3D; n +( 0 +1 + 2 + 3 + …)</li>
<li>与运算有“短路”作用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        n &amp;&amp; ( n += <span class="built_in">Sum_Solution</span>(n - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48.不用加减乘除做加法"></a>48.不用加减乘除做加法</h1><p>一眼位运算。</p>
<ul>
<li><strong>异或运算</strong>可以得到两数相加后各二进制位的<strong>非进位</strong>信息。（两数不同则是1，不同的话肯定一个0一个1，结果肯定是1）</li>
<li><strong>与运算</strong>可以得到进位信息。（与运算只有在两个数都是1的时候才会是1，即进位）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> carry = num2;</span><br><span class="line">        <span class="type">int</span> sum = num1;</span><br><span class="line">        <span class="keyword">while</span>(carry)&#123;</span><br><span class="line">            <span class="type">int</span> temp = sum ^ carry;</span><br><span class="line">            carry = (sum &amp; carry) &lt;&lt;<span class="number">1</span>;</span><br><span class="line">            sum = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="49-把字符串转换成整数"><a href="#49-把字符串转换成整数" class="headerlink" title="49.把字符串转换成整数"></a>49.把字符串转换成整数</h1><p><a href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&&tqId=11202&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">把字符串转换成整数_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>题目怎么说就怎么写，一位一位的数，遇见不对的直接返回0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">StrToInt</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;+&#x27;</span>) i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= str[i] &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                ans *= <span class="number">10</span>;</span><br><span class="line">                ans += str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) ans = -ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="50-数组中重复的数字"><a href="#50-数组中重复的数字" class="headerlink" title="50.数组中重复的数字"></a>50.数组中重复的数字</h1><p><a href="https://www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8?tpId=13&&tqId=11203&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">数组中重复的数字_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>题中给出的代码模板有一种C的味道。</p>
<h3 id="法一-17"><a href="#法一-17" class="headerlink" title="法一"></a>法一</h3><p>找第一个重复的数字，那就从头开始数，一边数一边用<code>unordered_map</code>记下来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">duplicate</span><span class="params">(<span class="type">int</span> numbers[], <span class="type">int</span> length, <span class="type">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">count</span>(numbers[i]))&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mp[numbers[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-20"><a href="#法二-20" class="headerlink" title="法二"></a>法二</h3><p>用vector来实现一个简化的哈希表也是个不错的方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">duplicate</span><span class="params">(<span class="type">int</span> numbers[], <span class="type">int</span> length, <span class="type">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vec</span><span class="params">(length,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[numbers[i]] == <span class="literal">false</span>) vec[numbers[i]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法三-4"><a href="#法三-4" class="headerlink" title="法三"></a>法三</h3><ul>
<li>数组中所有数都在0~n-1范围内。</li>
<li>在遍历过程中，将对应索引位置的数<code>＋n</code>。同时，只要遍历过程中遇见一个位置的数<code>&gt;=n</code>就表明，<strong>该位置对应的数重复了。</strong></li>
<li>可以这么做的原因是数组中所有数的范围是<code>0~n-1</code>，所以只要在遍历过程中对length取余就可以得到原始数据。而<code>原始数据 + n</code>相当于添加标志位类比于法二中的辅助数组。</li>
<li>举例，{1,2,1,3}中，n &#x3D; 4。<ul>
<li>第一次循环index &#x3D; 1，num[1] &#x3D; 2 + 4 &#x3D; 6。</li>
<li>第二次循环index &#x3D; 2,  num[2] &#x3D; 1 + 4 &#x3D; 5。</li>
<li>第三次循环index &#x3D; 1， num[1]  &gt; length。所以1重复了。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">duplicate</span><span class="params">(<span class="type">int</span> numbers[], <span class="type">int</span> length, <span class="type">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> index = numbers[i] % length;  <span class="comment">// 获取原始数值</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[index] &gt;= length)&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = index;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            numbers[index] += length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="51-构建乘积数组"><a href="#51-构建乘积数组" class="headerlink" title="51.构建乘积数组"></a>51.构建乘积数组</h1><p><a href="https://www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46?tpId=13&&tqId=11204&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">构建乘积数组_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>第一印象是求数组全部元素的乘积，然后每个位置都除以自己即可。但题目要求无法使用除法，只能另寻他法。</p>
<h3 id="法一-18"><a href="#法一-18" class="headerlink" title="法一"></a>法一</h3><p>啥也不管了，先暴力吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">multiply</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(A.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> mul = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;A.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j != i) mul *= A[j];</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = mul;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-21"><a href="#法二-21" class="headerlink" title="法二"></a>法二</h3><p>两次遍历。</p>
<p>乍看好像毫无头绪，但是细细琢磨发现<code>b[i]</code>等于a中除<code>a[i]</code>外所有元素的乘积，即<code>b[i] = i左边的元素乘积 * i右边的元素乘积</code>。而在一次遍历过程中左边或右边单独的乘积是可以累计的。</p>
<p>故，</p>
<ul>
<li>首先将b数组全部初始化为1。</li>
<li>第一次遍历，用<code>temp</code>记录遍历过程中<strong>从左开始</strong>的a中元素的累积，并将结果与<code>b[i]</code>相乘。</li>
<li>第二次遍历，依然用<code>temp</code>记录<strong>从右开始</strong>的a中元素的累积，并将结果与<code>b[i]</code>相乘。</li>
<li>得到最终结果。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">multiply</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(len,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            temp *= A[i - <span class="number">1</span>];</span><br><span class="line">            ans[i] *= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            temp *= A[i + <span class="number">1</span>];</span><br><span class="line">            ans[i] *= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="52-正则表达式匹配"><a href="#52-正则表达式匹配" class="headerlink" title="52.正则表达式匹配"></a>52.正则表达式匹配</h1><p><a href="https://www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c?tpId=13&&tqId=11205&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">正则表达式匹配_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>看起来就是实现正则表达式里的<code>.</code>和<code>*</code>。想不到怎么搞。</p>
<h3 id="法一-19"><a href="#法一-19" class="headerlink" title="法一"></a>法一</h3><p>C++11支持正则表达式了，但是牛客这里必须自己引入头文件，应该是后台的万能头文件不包括正则吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(string str, string pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">regex_match</span>(str,<span class="built_in">regex</span>(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-22"><a href="#法二-22" class="headerlink" title="法二"></a>法二</h3><p><a href="https://leetcode.cn/problems/regular-expression-matching/solutions/1/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8">直接开抄</a></p>
<p>首先，<code>.</code>就代表一个万能字符做特殊判定即可，困难的是<code>*</code>。</p>
<p>假设，abc与c*abc进行匹配，在从左向右匹配的过程中，首先a与c不匹配，发现不同但并不能做出“不匹配的判断”因为c后面还有一个<code>*</code>，代表字符可以出现任意次。所以，是否匹配还和当前字符后面跟着的符号有关。还需要去分情况讨论，很是困难。</p>
<p>但是，如果反过来看。从右边往左边匹配困难就少很多了。</p>
<p>假设<code>str = aab</code>，<code>pattern = c*a*b</code>。每次匹配过程，结果只和当前匹配的字符和左边的字符 有关，不需要考虑右边是否还跟着其他字符。需要讨论的情况就少了很多，而且问题可以转换为子问题——当前字符是否匹配 + 之前的串是否匹配。可以考虑动规。</p>
<ul>
<li><code>dp[i][j]</code>：长度为<code>i</code>的<code>str</code>与长度为<code>j</code>的<code>pattern</code>是否匹配。</li>
</ul>
<p>之后需要分情况讨论（分类依据是p中当前匹配字符是否是<code>*</code>，因为如果其是普通字符或者<code>.</code>可以直接比较）：</p>
<ol>
<li><code>p[i-1]!= &#39;*&#39;</code><ol>
<li>当前字符匹配成功，即<code>s[i-1]==p[j-1] || p[j -1] == &#39;*&#39;</code>，此时<code>dp[i][j] = dp[i-1][j-1]</code>（当前字符匹配成功，问题转换为之前的字符串是否匹配成功）</li>
<li>匹配不成功，<code>dp[i][j] = false;</code></li>
</ol>
</li>
<li><code>p[i-1]== &#39;*&#39;</code>比较<code>s[i-1]</code>与<code>p[j -2]</code>（<code>*</code>前的字符）<ol>
<li>不匹配，即<code>s[i - 1] != p[j - 2] &amp;&amp; p[j - 2] != &#39;.&#39;</code>，此时<code>dp[i][j] = dp[i][j - 2];</code>（跳过p中不匹配的部分继续匹配）</li>
<li>匹配，又有三种情况<ol>
<li>假设匹配0次，即匹配到了假装没匹配到直接跳过。此时<code>dp[i][j] = dp[i][j - 2];</code></li>
<li>假设匹配1次，此时<code>dp[i][j] = dp[i][j - 1];</code>此时相当于p中多了一个<code>*</code>，其余可以直接匹配，故直接跳过<code>*</code>即可。</li>
<li>假设匹配多次，此时<code>dp[i][j] = dp[i-1][j];</code>相当于p中有a<em>，代表aaa</em>。匹配过程中假设<code>s[i-1]</code>为可以匹配到的最后一个a，故直接跳过<code>s[i-1]</code>继续去比。</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m + <span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j - <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>] || p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;      <span class="comment">//p[j - 1] == &#x27;*&#x27;</span></span><br><span class="line">                    <span class="keyword">if</span>(s[i - <span class="number">1</span>] != p[j - <span class="number">2</span>] &amp;&amp; p[j - <span class="number">2</span>] != <span class="string">&#x27;.&#x27;</span>) dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = dp[i][j - <span class="number">2</span>] || dp[i][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码中，凡是出现在dp后面的<code>i</code>和<code>j</code>都表示字符串长度，凡是<code>s</code>和<code>p</code>后面的则都表示索引。</li>
</ul>
<h1 id="53-表示数值的字符串"><a href="#53-表示数值的字符串" class="headerlink" title="53.表示数值的字符串"></a>53.表示数值的字符串</h1><p><a href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/description/">LCR 138. 有效数字 - 力扣（LeetCode）</a></p>
<p>看不懂，直接开抄。</p>
<p><strong>有效数字</strong>（按顺序）可以分成以下几个部分：</p>
<ol>
<li>若干空格</li>
<li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li>
<li>（可选）一个 <code>&#39;e&#39;</code> 或 <code>&#39;E&#39;</code> ，后面跟着一个 <strong>整数</strong></li>
<li>若干空格</li>
</ol>
<p>将所有能正确表示数值的字符串的形势<strong>总结</strong>如下：</p>
<ul>
<li>空格只能出现在开头和结尾。</li>
<li><code>.</code>出现的正确情况： 只出现一次，且出现在<code>e</code>的前面。</li>
<li><code>e</code>出现的正确情况：只出现一次，且出现前有数字。</li>
<li><code>+-</code>出现的正确情况：只能在开头或e后一位。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validNumber</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 去掉首尾空格</span></span><br><span class="line">        <span class="type">int</span> start = s.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (start == string::npos) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> end = s.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        s = s.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> numFlag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> dotFlag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> eFlag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">                numFlag = <span class="literal">true</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//判断&#x27;.&#x27;的出现是否合法</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; !dotFlag &amp;&amp; !eFlag) &#123;</span><br><span class="line">                dotFlag = <span class="literal">true</span>;    </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 判断&#x27;e&#x27;的出现是否合法</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((s[i] == <span class="string">&#x27;e&#x27;</span> || s[i] == <span class="string">&#x27;E&#x27;</span>) &amp;&amp; !eFlag &amp;&amp; numFlag) &#123;</span><br><span class="line">                eFlag = <span class="literal">true</span>;</span><br><span class="line">                numFlag = <span class="literal">false</span>; <span class="comment">// &#x27;e&#x27;后面必须跟着整数</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 判断正负号出现是否合法</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; (i == <span class="number">0</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;E&#x27;</span>)) &#123;</span><br><span class="line">                <span class="comment">// 正确的位置不做处理</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 其他情况都不合法</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确保&#x27;e&#x27;或&#x27;E&#x27;后有数字</span></span><br><span class="line">        <span class="keyword">return</span> numFlag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="54-字符流中第一个不重复的字符"><a href="#54-字符流中第一个不重复的字符" class="headerlink" title="54.字符流中第一个不重复的字符"></a>54.字符流中第一个不重复的字符</h1><p><a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&&tqId=11207&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">字符流中第一个不重复的字符_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>初看懵逼的很，不明白<code>insert</code>这个函数有啥好用。后来才发现，这个是把字符串当作字符流。用<code>insert</code>在遍历字符串的同时，不断显示第一个不重复字符。</p>
<p>这就好说了。</p>
<h3 id="法一-20"><a href="#法一-20" class="headerlink" title="法一"></a>法一</h3><p>巧用库函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">         vec.<span class="built_in">push_back</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : vec)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">count</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),ch) == <span class="number">1</span>) <span class="keyword">return</span> ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-23"><a href="#法二-23" class="headerlink" title="法二"></a>法二</h3><p>不用库函数，用哈希表自己数。空间复杂度会高一点，但应该会稍微快一点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">         vec.<span class="built_in">push_back</span>(ch);</span><br><span class="line">         mp[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(vec.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; ch : vec)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[ch] == <span class="number">1</span>) <span class="keyword">return</span> ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="55-链表中环的入口结点"><a href="#55-链表中环的入口结点" class="headerlink" title="55.链表中环的入口结点"></a>55.链表中环的入口结点</h1><p><a href="https://leetcode.cn/problems/c32eOV/description/">LCR 022. 环形链表 II - 力扣（LeetCode）</a></p>
<p>直接开抄。<a href="https://www.programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">                ListNode* index1 = fast;</span><br><span class="line">                ListNode* index2 = head;</span><br><span class="line">                <span class="keyword">while</span>(index1 != index2)&#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="56-删除链表中重复的节点"><a href="#56-删除链表中重复的节点" class="headerlink" title="56.删除链表中重复的节点"></a>56.删除链表中重复的节点</h1><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II - 力扣（LeetCode）</a></p>
<h3 id="法一：-15"><a href="#法一：-15" class="headerlink" title="法一："></a>法一：</h3><p>与<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/">83. 删除排序链表中的重复元素 - 力扣（LeetCode）</a>很像。只不过本题重复的节点一个也不保留。这时候需要考虑第一个元素的处理问题。因为如果保留一个重复节点的话，第一个元素即使是重复的也需要保留，就不需要考虑了。但如果一个也不保留的话，第一个节点也有需要删除的可能性。</p>
<p>这时候，只要在原来代码的基础上新增加一个虚拟头节点，这样第一个节点就成了第二个，两个问题就统一起来了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val)&#123;</span><br><span class="line">                <span class="type">int</span> temp = cur-&gt;next-&gt;val;</span><br><span class="line">                <span class="keyword">while</span>( cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == temp)&#123;</span><br><span class="line">                    cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二：-11"><a href="#法二：-11" class="headerlink" title="法二："></a>法二：</h3><p>迭代法。将问题分解为当前节点的去留问题和后继链表的去除重复节点问题。</p>
<ul>
<li>递归出口：当前节点为空或没有后继节点。</li>
<li>递归问题：<ul>
<li>当前节点值与后继节点值不一致：当前节点需要保留，故<code>head-&gt;next = deleteDuplicates(head-&gt;next);</code>然后返回。</li>
<li>当前节点值与后继节点值一样：当前节点不需要保留，需要找到与当前节点值不一样的某个后继节点，从该节点开始继续迭代 <code>deleteDuplicates(temp)</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val != head-&gt;next-&gt;val)&#123;</span><br><span class="line">            head-&gt;next = <span class="built_in">deleteDuplicates</span>(head-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ListNode* temp = head-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>( temp &amp;&amp; temp-&gt;val == head-&gt;val)&#123;</span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">deleteDuplicates</span>(temp);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="57-二叉树的下一个结点"><a href="#57-二叉树的下一个结点" class="headerlink" title="57.二叉树的下一个结点"></a>57.二叉树的下一个结点</h1><p><a href="https://leetcode.cn/problems/successor-lcci/description/">面试题 04.06. 后继者 - 力扣（LeetCode）</a></p>
<h3 id="法一：-16"><a href="#法一：-16" class="headerlink" title="法一："></a>法一：</h3><p>很直观的一种写法。找中序遍历的下一个节点，那就中序遍历一次，把遍历顺序存在一个数组里，之后遍历一次数组就找到下一个了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nodes.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodes[i] == p &amp;&amp; i + <span class="number">1</span> &lt; nodes.<span class="built_in">size</span>()) <span class="keyword">return</span> nodes[i + <span class="number">1</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">        nodes.<span class="built_in">push_back</span>(root);</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;TreeNode*&gt; nodes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二：-12"><a href="#法二：-12" class="headerlink" title="法二："></a>法二：</h3><p>法一好像有点浪费空间，其实不需要把所有的遍历结果都存一遍，只要记录两个就行了。pre和cur。若<code>pre == p</code>，那么cur就是后继。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> || !st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(pre == p) <span class="keyword">return</span> cur;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&&tqId=11210&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">二叉树的下一个结点_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>牛课上这个差不多的题目给出的形式还不一样。牛客只给了一个节点，没有给出根节点所以不能直接遍历。但牛客上的树有一个next指针指向父亲节点，所以也好办。直接分情况讨论即可：</p>
<ul>
<li>p是空节点：返回nullptr</li>
<li>p有右孩子：中序遍历，所以有右孩子的话，下一个节点就是从右节点作为基准，开始找最左边的孩子。</li>
<li>p没有右孩子：<ul>
<li>若p的父亲节点<strong>是根节点</strong>的话：直接返回其父亲节点即可。</li>
<li>若p的父亲节点<strong>不是根节点</strong>的话：此时，按照左根右的遍历顺序来看，p的父亲节点一定是已经遍历过了。需要找到<strong>当前节点是其父节点的左子节点的那个父节点</strong>。（左根右体遍历顺序中，假设父亲节点为pre，当前节点为p。只要p是pre的右孩子，pre就一定已经遍历过了。当p是pre的左孩子时，p的下一个就是pre。）</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeLinkNode* <span class="title">GetNext</span><span class="params">(TreeLinkNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( p == <span class="literal">nullptr</span>) <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            TreeLinkNode* cur = p-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(cur-&gt;left)</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            TreeLinkNode* pre = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(pre-&gt;left == p) <span class="keyword">return</span> pre;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="58-判断对称的二叉树"><a href="#58-判断对称的二叉树" class="headerlink" title="58.判断对称的二叉树"></a>58.判断对称的二叉树</h1><p><a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/description/">LCR 145. 判断对称二叉树 - 力扣（LeetCode）</a></p>
<p>比较简单的一道题。注意对称判定的时候是左孩子的左子树和右孩子的右子树判定（其他类推）即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left, TreeNode* right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">compare</span>(left-&gt;left,right-&gt;right) &amp;&amp; <span class="built_in">compare</span>(left-&gt;right,right-&gt;left); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkSymmetricTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="59-按之字形顺序打印二叉树"><a href="#59-按之字形顺序打印二叉树" class="headerlink" title="59.按之字形顺序打印二叉树"></a>59.按之字形顺序打印二叉树</h1><p><a href="https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&&tqId=11212&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">按之字形顺序打印二叉树_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h3 id="法一-21"><a href="#法一-21" class="headerlink" title="法一"></a>法一</h3><p>第一印象，直接层序遍历，然后将偶数位置的数组翻转一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">Print</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;ans.<span class="built_in">size</span>();i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">reverse</span>(ans[i].<span class="built_in">begin</span>(),ans[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-24"><a href="#法二-24" class="headerlink" title="法二"></a>法二</h3><p>也可以用一个标志位，在插入时就直接改变插入方向。这里就用odd作为奇数行标志位</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">Print</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">bool</span> odd = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(odd)</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    vec.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>(), node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            odd = !odd;  <span class="comment">// 遍历完一行了，标志一下方向变了</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="60-把二叉树打印成多行"><a href="#60-把二叉树打印成多行" class="headerlink" title="60.把二叉树打印成多行"></a>60.把二叉树打印成多行</h1><p><a href="https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&&tqId=11213&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">把二叉树打印成多行_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>这不是一个标标准准的层序遍历吗</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">Print</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="61-序列化二叉树"><a href="#61-序列化二叉树" class="headerlink" title="61.序列化二叉树"></a>61.序列化二叉树</h1><p><a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/description/">297. 二叉树的序列化与反序列化 - 力扣（LeetCode）</a></p>
<p>直接开抄。</p>
<p>二叉树的序列化最大的问题是如何<strong>唯一的表示一棵树</strong>。</p>
<ul>
<li>单独的前中后序遍历都无法唯一表示一棵树。（前+ 后这种的才能确定一棵树）</li>
<li>如果要唯一表示，可以采用层序遍历，然后遍历过程中将<code>nullptr</code>节点也记录下来，这里记做<code>null</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&#x27;,&#x27;</span> + <span class="built_in">serialize</span>(root-&gt;left) + <span class="string">&#x27;,&#x27;</span> + <span class="built_in">serialize</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        queue&lt;string&gt; que;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line">        string item;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(ss,item,<span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">            que.<span class="built_in">push</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">deserializeHelper</span>(que);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserializeHelper</span><span class="params">(queue&lt;string&gt;&amp; que)</span></span>&#123;</span><br><span class="line">        string val = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(val == <span class="string">&quot;null&quot;</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(val));</span><br><span class="line">        node-&gt;left = <span class="built_in">deserializeHelper</span>(que);</span><br><span class="line">        node-&gt;right = <span class="built_in">deserializeHelper</span>(que);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser, deser;</span></span><br><span class="line"><span class="comment">// TreeNode* ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure>

<h1 id="62-二叉搜索树中第k小的元素"><a href="#62-二叉搜索树中第k小的元素" class="headerlink" title="62.二叉搜索树中第k小的元素"></a>62.二叉搜索树中第k小的元素</h1><p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/">230. 二叉搜索树中第K小的元素 - 力扣（LeetCode）</a></p>
<p>由于是二叉搜索树，中序遍历的顺序就是从小到大的顺序。所以直接用迭代法遍历一次，每遍历一个数k减1，k减为0时就找到了第k小的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> || !st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                k--;</span><br><span class="line">                <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="63-数据流中的中位数"><a href="#63-数据流中的中位数" class="headerlink" title="63.数据流中的中位数"></a>63.数据流中的中位数</h1><p><a href="https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&&tqId=11216&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">数据流中的中位数_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数 - 力扣（LeetCode）</a></p>
<p>涉及到数据流的题目，牛客和力扣的表现形式好像都不太一致。但本质是一样的。</p>
<h3 id="法一-22"><a href="#法一-22" class="headerlink" title="法一"></a>法一</h3><p>本分老实人，说求中位数那就求，直接求。但是力扣上有规模特别大的数据，这样搞会超时。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetMedian</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> len = vec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>)(vec[len / <span class="number">2</span>] + vec[len / <span class="number">2</span> - <span class="number">1</span>])/ <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> vec[len / <span class="number">2</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-25"><a href="#法二-25" class="headerlink" title="法二"></a>法二</h3><p>需要进行优化。法一最大的时间消耗就是每次GetMedian都需要进行排序，数据量大的时候很浪费时间。</p>
<ul>
<li>如果能在插入数据时，使数组中的元素保持有序就不需要排序了。</li>
<li>可以在插入的时候用二分搜索找到插入位置。</li>
</ul>
<p>这样优化以后力扣能多过一点数据了，但还是不能全过去，21个用例，过了20个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">getPos</span>(num);</span><br><span class="line">        vec.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>() + pos, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetMedian</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="type">int</span> len = vec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>)(vec[len / <span class="number">2</span>] + vec[len / <span class="number">2</span> - <span class="number">1</span>])/ <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> vec[len / <span class="number">2</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getPos</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = vec.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(num &lt; vec[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; vec[mid]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法三-5"><a href="#法三-5" class="headerlink" title="法三"></a>法三</h3><p>继续优化，感觉vector这个数据结构能换一换，每次在vector中间插入元素，从插入位置开始后面所有元素都要移动，这个是O(N)的。</p>
<ul>
<li>可以用multiset来代替vector，它是基于红黑树实现的，插入时间复杂度是O(logn)。</li>
</ul>
<p>这个在两个平台都通过了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>():<span class="built_in">mid</span>(mst.<span class="built_in">end</span>())&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = mst.<span class="built_in">size</span>();</span><br><span class="line">        mst.<span class="built_in">insert</span>(num);</span><br><span class="line">        <span class="keyword">if</span>(!n)   <span class="comment">// 若multiset为空，设置mid为begin迭代器</span></span><br><span class="line">            mid = mst.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(num &lt; *mid)  <span class="comment">// num小于中位数：若n为奇数，mid不变；若n是偶数，mid向前移动。</span></span><br><span class="line">            mid = (n &amp; <span class="number">1</span>) ? mid : <span class="built_in">prev</span>(mid);</span><br><span class="line">        <span class="keyword">else</span>        <span class="comment">// num大于等于中位数：若n为奇数，mid向后移动；若n是偶数，mid不变</span></span><br><span class="line">            mid = (n &amp; <span class="number">1</span>) ? <span class="built_in">next</span>(mid) : mid;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetMedian</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="type">int</span> n = mst.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 若n是奇数，next(mid,n %2 - 1) 返回mid本身，若n是偶数，则返回mid前一个元素</span></span><br><span class="line">        <span class="keyword">return</span> ((<span class="type">double</span>)(*mid) + *<span class="built_in">next</span>(mid,n %<span class="number">2</span> - <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt; mst;</span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt;::iterator mid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法四"><a href="#法四" class="headerlink" title="法四"></a>法四</h3><p>经典的大小堆算法。</p>
<ul>
<li>数据结构<ul>
<li>用一个小顶堆存储右半部分，right。</li>
<li>用一个大顶堆存储左半部分，left。</li>
</ul>
</li>
<li>数据个数关系：假设元素数量为N。<ul>
<li>如果N为偶数，left和right中元素数量相同。</li>
<li>如果N为奇数，right中元素数量要比left中多一。(人为规定，可以反过来)</li>
</ul>
</li>
<li>插入时，假设left中有m个元素，right中有n个元素。<ul>
<li><code>m = n</code>：（N为偶数）需要向right中添加一个元素。实现：将新元素num添加到left，再将left堆顶元素插入到right。<ul>
<li>不能直接插入到right中，因为num大小未知，若其比较小，则其位置应该在left的中间。</li>
<li>先往小的里面插，然后把小的里面的最大的插到大的里面去。如果一开始就插大的，后来发现很小那就直接错了。</li>
</ul>
</li>
<li><code>m != n</code>：（N为奇数）这时候需要向left里插入一个元素。实现方法：将新元素插入到right，再将right的堆顶元素插入到left。</li>
</ul>
</li>
<li>添加一个数字的时间复杂度是O(logn)，查找中位数的时间复杂度是O(1)。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left.<span class="built_in">size</span>() != right.<span class="built_in">size</span>())&#123;  <span class="comment">// 奇数</span></span><br><span class="line">            right.<span class="built_in">push</span>(num);</span><br><span class="line">            left.<span class="built_in">push</span>(right.<span class="built_in">top</span>());</span><br><span class="line">            right.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;      <span class="comment">// 偶数</span></span><br><span class="line">            left.<span class="built_in">push</span>(num);</span><br><span class="line">            right.<span class="built_in">push</span>(left.<span class="built_in">top</span>());</span><br><span class="line">            left.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetMedian</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> (right.<span class="built_in">size</span>() != left.<span class="built_in">size</span>()) ? right.<span class="built_in">top</span>() : (<span class="type">double</span>)(right.<span class="built_in">top</span>() + left.<span class="built_in">top</span>()) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; right;  <span class="comment">// 小顶堆，数组右半边</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;&gt; left;   <span class="comment">// 大顶堆，数组左半边</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="64-滑动窗口的最大值"><a href="#64-滑动窗口的最大值" class="headerlink" title="64.滑动窗口的最大值"></a>64.滑动窗口的最大值</h1><p><a href="https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=13&&tqId=11217&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">滑动窗口的最大值_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p><a href="https://leetcode.cn/problems/sliding-window-maximum/description/">239. 滑动窗口最大值 - 力扣（LeetCode）</a></p>
<h3 id="法一-23"><a href="#法一-23" class="headerlink" title="法一"></a>法一</h3><ul>
<li>滑动窗口需要从左边删除数据，还需要从右边插入数据，所以用双端队列最为合适。</li>
<li>还需要动态求最大值，可以想到“求下一个最大的值”的单调栈思想。<ul>
<li>对于窗口中的两个位置i和j。<code>i&lt; j</code>，如果<code>i</code>对应的元素不大于<code>j</code>对应的元素。那么在窗口滑动的过程中，只要<code>i</code>还存在，<code>nums[i]</code>一定不是滑动窗口中最大值。（在队列中遍历时只需要保留一个最大值就好了）。这时候<code>i</code>这个位置是没必要保存的。</li>
</ul>
</li>
<li>实现原理：<ol>
<li>使用deque存储<strong>有潜力成为最大值的元素索引</strong>。</li>
<li>遍历nums，遍历过程中<ol>
<li>先检查头部元素（存的是索引），若其与当前元素索引之差等于窗口大小说明该元素已经不再窗口里了，需要移除。——这就是在插入元素时，只把比当前元素小的元素pop出去的原因。如果插入元素比队列中元素小，那么一旦删除了队头元素，该元素就可能成为窗口中的最大值。</li>
<li>之后检查尾部元素，将队列中索引值对应的元素值小于当前元素的都pop出去，既然比当前元素小，只要当前元素在窗口内，这些元素永无出头之日。</li>
<li>将当前元素插入队列尾部。</li>
</ol>
</li>
<li>继续遍历nums，知道遍历完整个数组。遍历过程中，不要忘记存储最大值，用作最后返回。</li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; deq;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 移除不在滑动窗口内的元素索引</span></span><br><span class="line">            <span class="keyword">if</span>(!deq.<span class="built_in">empty</span>() &amp;&amp; deq.<span class="built_in">front</span>() == i - k) deq.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="comment">// 移除队列中小于当前元素nums[i]的索引</span></span><br><span class="line">            <span class="comment">// 队列中元素代表滑动窗口内元素，若是其小于nums[i]表示其肯定不可能是最大值了</span></span><br><span class="line">            <span class="keyword">while</span>(!deq.<span class="built_in">empty</span>() &amp;&amp; nums[deq.<span class="built_in">back</span>()] &lt; nums[i]) deq.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="comment">// 当前元素加入队列</span></span><br><span class="line">            deq.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="comment">// 窗口形成后，将最大值（队列头部）加入结果</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(nums[deq.<span class="built_in">front</span>()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-26"><a href="#法二-26" class="headerlink" title="法二"></a>法二</h3><p>相当于从第k个元素开始不断求当前窗口内的最大值。</p>
<ul>
<li>很容易可以想到用优先队列可以动态维护一个最大值。但是，优先队列无法记录当前最大值在原数组中是第几个。</li>
<li>优先队列中的元素用<code>pair&lt;元素，索引&gt;</code>，这样就可以在动态维护最大值的同时，记录当前最大值对应的索引元素，在该索引下的元素滑出窗口时将其出队。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,less&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; pq;  <span class="comment">//大顶堆，存放&#123;元素，索引&#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;k;i++) pq.<span class="built_in">push</span>(&#123;nums[i],i&#125;); <span class="comment">// 把前n个元素放入大顶堆</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans = &#123;pq.<span class="built_in">top</span>().first&#125;; <span class="comment">// 直接将第一个元素放入结果数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;nums[i],i&#125;);</span><br><span class="line">            <span class="keyword">while</span>(pq.<span class="built_in">top</span>().second &lt; i - k + <span class="number">1</span>) </span><br><span class="line">								pq.<span class="built_in">pop</span>();  <span class="comment">// 将已经不在窗口内的最大值去除</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="65-矩阵中的路径"><a href="#65-矩阵中的路径" class="headerlink" title="65.矩阵中的路径"></a>65.矩阵中的路径</h1><p><a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&&tqId=11218&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">矩阵中的路径_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p><a href="https://leetcode.cn/problems/word-search/description/">79. 单词搜索 - 力扣（LeetCode）</a></p>
<p>直接暴力回溯。但是牛客上给出的代码模板没有用vector，只有<code>char*</code>的字符串，一个比较好的方法就是拿到以前先将其转换成<code>vector&lt;vector&lt;char&gt;&gt;</code>，有STL为啥不用呢。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board,<span class="type">const</span> string&amp; word,<span class="type">int</span> i ,<span class="type">int</span> j ,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= board.<span class="built_in">size</span>() || i &lt; <span class="number">0</span></span><br><span class="line">            || j &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() || j &lt; <span class="number">0</span></span><br><span class="line">            || word[k] != board[i][j]) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 排除越界和字母不相等的情况</span></span><br><span class="line">        <span class="keyword">if</span>(k == word.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 找到单词了，直接返回true</span></span><br><span class="line">        board[i][j] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 同一单元格的字母不允许重复使用，所以已经用过的要标记一下</span></span><br><span class="line">        <span class="type">bool</span> ans = <span class="built_in">check</span>(board,word,i + <span class="number">1</span>,j,k + <span class="number">1</span>) || <span class="built_in">check</span>(board,word,i,j + <span class="number">1</span>,k + <span class="number">1</span>)</span><br><span class="line">                || <span class="built_in">check</span>(board,word,i - <span class="number">1</span>,j, k + <span class="number">1</span>) || <span class="built_in">check</span>(board,word,i,j - <span class="number">1</span>,k + <span class="number">1</span>);</span><br><span class="line">        board[i][j] = word[k]; <span class="comment">// 恢复现场，本轮遍历已经结果，要把原来的数组恢复到原来的样子否则会影响下一次判断</span></span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h = board.<span class="built_in">size</span>(), w = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;h;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;w;j++)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(board,word,i,j,<span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="66-机器人的运动范围"><a href="#66-机器人的运动范围" class="headerlink" title="66.机器人的运动范围"></a>66.机器人的运动范围</h1><p><a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&&tqId=11219&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">机器人的运动范围_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p><a href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">LCR 130. 衣橱整理 - 力扣（LeetCode）</a></p>
<p>力扣上的题目不一样，但就是换了个皮，内核一样，还是直接暴力。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDigit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> sum =  <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            sum += x % <span class="number">10</span> ;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> m,<span class="type">int</span> n,<span class="type">int</span> cnt,vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n</span><br><span class="line">        || visited[i][j]   <span class="comment">// has visited</span></span><br><span class="line">        || <span class="built_in">getDigit</span>(i) + <span class="built_in">getDigit</span>(j) &gt; cnt)  <span class="comment">// don&#x27;t need calc </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> +  <span class="built_in">dfs</span>(i + <span class="number">1</span>,j,m,n,cnt,visited) + <span class="built_in">dfs</span>(i ,j + <span class="number">1</span>,m ,n,cnt,visited) + </span><br><span class="line">                    <span class="built_in">dfs</span>(i- <span class="number">1</span>,j,m,n,cnt,visited) + <span class="built_in">dfs</span>(i ,j - <span class="number">1</span>,m,n,cnt,visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wardrobeFinishing</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(m,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n,<span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,m,n,cnt,visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="67-剪绳子"><a href="#67-剪绳子" class="headerlink" title="67.剪绳子"></a>67.剪绳子</h1><p><a href="https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8?tpId=13&&tqId=33257&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">剪绳子_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p><a href="https://leetcode.cn/problems/integer-break/description/">343. 整数拆分 - 力扣（LeetCode）</a></p>
<h3 id="法一-24"><a href="#法一-24" class="headerlink" title="法一"></a>法一</h3><p>使用dp。</p>
<ul>
<li>定义<code>dp[i]</code>表示拆分<code>i</code>后得到的最大乘积。</li>
<li>递推公式：<code>dp[i] = max(dp[i],dp[j]*dp[i - j])</code><ul>
<li>表面上看只是拆分为了两部分，但是<code>dp[i]</code>代表的是<code>i</code>拆分后得到的最大乘积而不是<code>i</code>本身。</li>
<li>其代表的不是一个数而是一个最大乘积积，是一个或多个数的乘积。例如，<code>dp[8]</code>可以拆分为<code>dp[1]</code>和<code>dp[7]</code>。而<code>dp[7]</code>并不等于7，其等于<code>dp[3]*dp[4]</code>。</li>
</ul>
</li>
<li>初始化。初始化过程中要首先2和3需要特殊判定。因为这两个数拆分后的乘积是比自己小的。所以其需要单独return，而在dp数组中<code>dp[2]</code>和<code>dp[3]</code>都应该以2和3的身份出现<ul>
<li>因为题目要求至少拆分为两项，在递推公式中已经保证了将整数至少拆分为两项。</li>
<li>所以，这里2和3这里不需要拆分，直接以本身的形式出现保证最后取得的乘积最大。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= i / <span class="number">2</span>;j++)&#123;  <span class="comment">// 拆分后的所有结果是对称的只要取一半就行了</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i],dp[j] * dp[i - j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="法二-27"><a href="#法二-27" class="headerlink" title="法二"></a>法二</h3><p>法一的写法很直观，但对于2和3需要有个特判，不太统一显得不是特别优雅。</p>
<p>此外，对于<code>dp[2]</code>和<code>dp[3]</code>表示的也不是<code>dp[i]</code>拆分后的最大乘积了，与最初dp[i]的定义略有不符，所以有点不太美观。</p>
<p>其实，上面这些不统一的<strong>本质在于2和3拆分后的乘积比本身要小</strong>。所以，我们递推公式写成这样<code>dp[i] = max(dp[i],max(j* (i - j),j * dp[i - j]));</code></p>
<ul>
<li>其中<code>j * (i - j)</code>是单纯将<code>i</code>拆分为两个整数来乘，<code>j * dp[i - j]</code>则是拆分为两个以及两个以上是数来成。而<code>j</code>本身又考虑了所有可能的情况，所以已经覆盖了所有可能的情况。</li>
<li>注意<code>j * dp[i - j]</code>不能写成<code>dp[j]* dp[i - j]</code>。因为改完后貌似将<code>j</code>又进一步进行了拆分考虑的情况更完全了，但其在面对<code>j &gt; dp[j]</code>情况时得到的结果是比<code>j * dp[i - j]</code>小的就会忽略掉真正的最大乘积。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;= i / <span class="number">2</span>;j++)&#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i],<span class="built_in">max</span>(j* (i - j),j * dp[i - j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
